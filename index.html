<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å³æ™‚äº’å‹•æ•¸ä½ç™½æ¿</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fabric.js for canvas manipulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    
    <!-- PDF.js for PDF rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      // Specify workerSrc for pdf.js
      pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
    </script>

    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* Custom styles */
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; }


        /* Style for selected tool */
        .tool-btn.active {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6;
        }
        .pen-width-btn {
            background-color: #4b5563; /* gray-600 */
            color: white;
        }
        .pen-width-btn.active {
            background-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6;
        }
        canvas {
            cursor: default;
        }
        /* Hide file inputs */
        #image-input, #pdf-input {
            display: none;
        }
        /* Custom scrollbar for PDF preview */
        .pdf-preview-grid::-webkit-scrollbar {
            width: 8px;
        }
        .pdf-preview-grid::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .pdf-preview-grid::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .pdf-preview-grid::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Style for code block in modal */
        .code-block {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="bg-gray-100 overflow-hidden">

    <!-- Landing View: Role selection and session management -->
    <div id="landing-view" class="relative h-screen w-screen flex items-center justify-center p-4 bg-gradient-to-br from-blue-50 via-white to-green-50">
        <a href="https://filedn.com/laMtL9jmKf7JrDEQG0A6OPy/html/firebase-%E4%BA%92%E5%8B%95%E7%99%BD%E6%9D%BF/%E5%8D%B3%E6%99%82%E4%BA%92%E5%8B%95%E6%95%B8%E4%BD%8D%E7%99%BD%E6%9D%BF_%E6%95%99%E5%B8%AB%E5%BB%BA%E7%BD%AE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8A.html" target="_blank" rel="noopener noreferrer" class="absolute top-4 right-4 bg-amber-500 text-white px-3 py-2 rounded-xl shadow-lg hover:bg-amber-600 transition-colors duration-300 text-sm font-bold flex items-center bg-opacity-90 backdrop-blur-sm z-10">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-1.5"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
            <span>å»ºç½®æ“ä½œæ‰‹å†Š</span>
        </a>
        <div class="w-full max-w-6xl">
            <!-- Header -->
            <div class="text-center mb-12">
                <h1 class="text-5xl font-bold text-gray-800 mb-3">ğŸ“ å³æ™‚äº’å‹•æ•¸ä½ç™½æ¿</h1>
                <p class="text-xl text-gray-600">å°ˆç‚ºå¸«ç”Ÿè¨­è¨ˆçš„å”ä½œç©ºé–“ âœ¨</p>
            </div>

            <!-- Two Column Layout -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- Teacher Section -->
                <div class="bg-white rounded-2xl shadow-2xl p-8 border-4 border-blue-200 hover:border-blue-400 transition-all duration-300 transform hover:scale-105">
                    <div class="text-center mb-6">
                        <div class="text-6xl mb-4">ğŸ‘¨â€ğŸ«</div>
                        <h2 class="text-3xl font-bold text-blue-600 mb-2">æ•™å¸«å°ˆå€</h2>
                        <p class="text-gray-500">å»ºç«‹æˆ–é€²å…¥æ‚¨çš„æ•™å­¸ç™½æ¿</p>
                    </div>
                    <div id="teacher-login-step1" class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ” æ•™å¸«å¯†ç¢¼</label>
                            <input id="teacher-password" type="password" placeholder="è«‹è¼¸å…¥æ•™å¸«å¯†ç¢¼" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition">
                        </div>
                        <button id="teacher-password-submit-btn" class="w-full bg-gradient-to-r from-blue-500 to-blue-600 text-white py-3 rounded-lg hover:from-blue-600 hover:to-blue-700 transition font-bold text-lg shadow-md hover:shadow-lg">
                            ä¸‹ä¸€æ­¥
                        </button>
                    </div>
                    <div id="teacher-login-step2" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ“‚ é¸æ“‡ç¾æœ‰ç™½æ¿</label>
                            <div class="flex items-center space-x-2">
                                <select id="existing-sessions-dropdown" class="flex-grow px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition">
                                    <option value="">-- è«‹é¸æ“‡æˆ–æ–¼ä¸‹æ–¹è¼¸å…¥æ–°ID --</option>
                                    <!-- Options will be populated by JS -->
                                </select>
                                <button id="delete-selected-session-btn" class="hidden p-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition" title="åˆªé™¤é¸å–çš„ç™½æ¿">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
                                </button>
                            </div>
                        </div>
                        <div class="text-center text-gray-500 text-sm">æˆ–</div>
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">âœï¸ è¼¸å…¥æ–°ç™½æ¿ID (æˆ–ç•™ç©ºè‡ªå‹•ç”Ÿæˆ)</label>
                            <input id="session-id-teacher" type="text" placeholder="è‡ªè¨‚IDæˆ–ç•™ç©º" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition">
                        </div>
                        <button id="enter-whiteboard-btn" class="w-full bg-gradient-to-r from-green-600 to-green-700 text-white py-4 rounded-lg hover:from-green-700 hover:to-green-800 transition font-bold text-lg shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                            ğŸš€ é€²å…¥ç™½æ¿
                        </button>
                        <div class="relative my-4">
                            <div class="absolute inset-0 flex items-center" aria-hidden="true">
                                <div class="w-full border-t border-gray-300"></div>
                            </div>
                            <div class="relative flex justify-center">
                                <span class="bg-white px-2 text-sm text-gray-500">å±éšªæ“ä½œ</span>
                            </div>
                        </div>
                        <button id="close-session-btn" class="w-full bg-gradient-to-r from-red-700 to-red-800 text-white py-3 rounded-lg hover:from-red-800 hover:to-red-900 transition font-bold text-lg shadow-md hover:shadow-lg flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>
                            <span>æ¸…ç©ºæ•´å€‹è³‡æ–™åº« (åˆªé™¤æ‰€æœ‰ç™½æ¿)</span>
                        </button>
                    </div>
                </div>

                <!-- Student Section -->
                <div class="bg-white rounded-2xl shadow-2xl p-8 border-4 border-green-200 hover:border-green-400 transition-all duration-300 transform hover:scale-105">
                    <div class="text-center mb-6">
                        <div class="text-6xl mb-4">ğŸ‘¨â€ğŸ“</div>
                        <h2 class="text-3xl font-bold text-green-600 mb-2">å­¸ç”Ÿå°ˆå€</h2>
                        <p class="text-gray-500">åŠ å…¥è€å¸«çš„æ•™å­¸ç™½æ¿</p>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ‘¤ æ‚¨çš„å§“å</label>
                            <input id="student-name" type="text" placeholder="è«‹è¼¸å…¥æ‚¨çš„å§“å" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition">
                        </div>
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ”‘ ç™½æ¿ID</label>
                            <input id="session-id-student" type="text" placeholder="è«‹è¼¸å…¥è€å¸«æä¾›çš„ID" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition">
                        </div>
                        <button id="join-session-btn" class="w-full bg-gradient-to-r from-green-600 to-green-700 text-white py-4 rounded-lg hover:from-green-700 hover:to-green-800 transition font-bold text-lg shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                            âœ… åŠ å…¥ç™½æ¿
                        </button>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div class="text-center mt-8 space-y-2">
                <button id="show-setup-btn" class="text-sm text-gray-500 hover:text-blue-600 underline transition">
                    â“ éœ€è¦å¹«åŠ©ï¼Ÿé»æ­¤æŸ¥çœ‹ Firebase è¨­å®šèªªæ˜
                </button>
                <div class="text-gray-500 text-sm">
                    Made with â¤ï¸ by <a href="https://kentxchang.blogspot.tw" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:text-blue-700 font-semibold underline">é˜¿å‰›è€å¸«</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Whiteboard View -->
    <div id="whiteboard-view" class="hidden h-screen w-screen relative">
        <!-- Pages Toolbar -->
        <div id="pages-toolbar" class="fixed top-1/2 -translate-y-1/2 left-4 bg-gray-800 bg-opacity-90 backdrop-blur-sm text-white p-2 rounded-xl shadow-lg flex flex-col items-center space-y-2 z-20 max-h-[80vh] overflow-y-auto">
            <!-- Pages will be rendered here by JS -->
        </div>

        <canvas id="whiteboard-canvas"></canvas>
        
        <!-- Teacher Lock Message -->
        <div id="lock-message" class="hidden fixed bottom-16 left-1/2 -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-lg shadow-lg z-30 text-lg font-bold animate-pulse">
            æ•™å¸«é–å®šä¸­...
        </div>

        <!-- Floating Toolbar -->
        <div id="toolbar" class="toolbar fixed bottom-4 left-1/2 -translate-x-1/2 bg-gray-800 bg-opacity-90 backdrop-blur-sm text-white p-2 rounded-xl shadow-lg flex flex-nowrap items-center space-x-1 z-20">
            <!-- Basic Tools -->
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="pan" title="ç§»å‹•ç•«å¸ƒ (H)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11V6l-5 5 5 5v-5h6v5l5-5-5-5v5H9z"/></svg>
            </button>
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="select" title="é¸å–/ç§»å‹• (V)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>
            </button>
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="pen" title="ç•«ç­† (P)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>
            </button>
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="rect" title="çŸ©å½¢ (R)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>
            </button>
             <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="circle" title="åœ“å½¢ (C)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>
            </button>
            <div id="pen-options" class="hidden flex items-center space-x-2 pl-2">
                <input type="color" id="pen-color" value="#3b82f6" class="w-8 h-8 rounded-full cursor-pointer bg-transparent border-none" title="ç•«ç­†é¡è‰²">
                <button data-width="5" class="pen-width-btn w-6 h-6 rounded-lg flex items-center justify-center text-sm font-semibold">5</button>
                <button data-width="10" class="pen-width-btn w-6 h-6 rounded-lg flex items-center justify-center text-sm font-semibold">10</button>
                <button data-width="20" class="pen-width-btn w-6 h-6 rounded-lg flex items-center justify-center text-sm font-semibold">20</button>
            </div>

            <div class="w-px h-8 bg-gray-600"></div>

            <!-- Content Tools -->
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="note" title="ä¾¿åˆ©è²¼ (N)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3Z"/><path d="M15 3v6h6"/></svg>
            </button>
            <div id="note-options" class="hidden items-center space-x-1 pl-1">
                <button data-color="#FFFBEB" class="w-6 h-6 rounded-full bg-yellow-100 border-2 border-white" title="é»ƒè‰²ä¾¿åˆ©è²¼"></button>
                <button data-color="#EFF6FF" class="w-6 h-6 rounded-full bg-blue-100 border-2 border-white" title="è—è‰²ä¾¿åˆ©è²¼"></button>
                <button data-color="#FCE7F3" class="w-6 h-6 rounded-full bg-pink-100 border-2 border-white" title="ç²‰è‰²ä¾¿åˆ©è²¼"></button>
                <button data-color="#F0FDF4" class="w-6 h-6 rounded-full bg-green-100 border-2 border-white" title="ç¶ è‰²ä¾¿åˆ©è²¼"></button>
            </div>

            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" id="upload-image-btn" title="æ’å…¥åœ–ç‰‡ (I)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
            </button>
            <input type="file" id="image-input" accept="image/*">

            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" id="upload-pdf-btn" title="æ’å…¥PDF (F)">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
            </button>
            <input type="file" id="pdf-input" accept=".pdf">

            <div class="w-px h-8 bg-gray-600"></div>

            <!-- Action Tools -->
             <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="delete" title="åˆªé™¤é¸å– (Delete)">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
            </button>

            <!-- Teacher Only Tools -->
            <div id="teacher-tools" class="hidden flex items-center">
                <div class="w-px h-8 bg-gray-600 mx-1"></div>
                <button id="lock-students-btn" class="p-3 rounded-lg hover:bg-gray-700 flex items-center" title="é–å®š/è§£é–å­¸ç”Ÿå·¥å…·">
                    <svg id="lock-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                </button>
                <button id="toggle-author-names-btn" class="p-3 rounded-lg hover:bg-gray-700 flex items-center" title="é¡¯ç¤º/éš±è—ä½œè€…å§“å">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                </button>
                <div class="w-px h-8 bg-gray-600 mx-1"></div>
                <button id="download-pdf-btn" class="p-3 rounded-lg text-green-500 hover:bg-green-500 hover:text-white" title="ä¸‹è¼‰æ‰€æœ‰ç•«å¸ƒç‚ºPDF">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                </button>
                <div class="w-px h-8 bg-gray-600 mx-1"></div>
                <button id="leave-session-btn" class="p-3 rounded-lg text-yellow-500 hover:bg-yellow-500 hover:text-white" title="é›¢é–‹ç™½æ¿ï¼ˆä¸åˆªé™¤è³‡æ–™ï¼‰">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                </button>
            </div>
        </div>

        <!-- Session Info Container -->
        <div class="absolute top-4 left-4 flex space-x-2 z-10">
            <div id="session-info" class="bg-white bg-opacity-80 backdrop-blur-sm px-4 py-2 rounded-lg shadow-md">
                ç™½æ¿ID: <span id="session-id-display" class="font-bold text-blue-600"></span>
            </div>
             <div id="student-name-display-container" class="hidden bg-white bg-opacity-80 backdrop-blur-sm px-4 py-2 rounded-lg shadow-md">
                å§“å: <span id="student-name-display" class="font-bold text-purple-600"></span>
            </div>
             <div id="participant-info" class="bg-white bg-opacity-80 backdrop-blur-sm px-4 py-2 rounded-lg shadow-md">
                <span id="participant-display" class="font-semibold text-green-600">ç·šä¸Šäººæ•¸: 0</span>
            </div>
        </div>
        
        <!-- Author Names Toggle Button is now integrated into the main toolbar -->


        <!-- Zoom Control -->
        <div id="zoom-control" class="absolute top-4 right-4 bg-gray-800 bg-opacity-90 backdrop-blur-sm text-white p-2 rounded-xl shadow-lg z-20 flex items-center space-x-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
            <input type="range" id="zoom-slider" min="0.1" max="4" step="0.01" value="1" class="w-32">
            <span id="zoom-label" class="text-sm w-12 text-center">100%</span>
        </div>


    </div>

    <!-- Participant List Modal -->
    <div id="participant-list-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md h-[70vh] flex flex-col">
            <div class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold">ç·šä¸Šåƒèˆ‡è€…</h2>
                <button id="close-participant-list-modal" class="text-gray-500 hover:text-gray-800 text-3xl font-bold leading-none">&times;</button>
            </div>
            <div id="participant-list-container" class="p-4 flex-grow overflow-y-auto space-y-2">
                <!-- Participant list will be rendered here -->
            </div>
            <div class="p-4 border-t flex justify-end">
                <button id="refresh-participant-list-btn" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">é‡æ–°æ•´ç†</button>
            </div>
        </div>
    </div>

    <!-- Firebase Setup Modal -->
    <div id="setup-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-60 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-3xl p-8 space-y-4 relative max-h-[90vh] overflow-y-auto">
            <button id="close-setup-btn" class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 text-3xl font-bold leading-none">&times;</button>
            <h2 class="text-2xl font-bold text-center text-red-600">å®Œæ•´ Firebase è¨­å®šæ•™å­¸</h2>
            <p class="text-center text-gray-600">è«‹ä¾ç…§ä»¥ä¸‹è©³ç´°æ­¥é©Ÿï¼Œä¸€æ­¥æ­¥å®Œæˆè¨­å®šï¼Œè®“æ‚¨çš„æ•¸ä½ç™½æ¿é †åˆ©é‹ä½œã€‚</p>
            
            <div class="text-sm space-y-4 text-left">
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬ä¸€æ­¥ï¼šå»ºç«‹ Firebase å°ˆæ¡ˆ</h3>
                    <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>å‰å¾€ <a href="https://console.firebase.google.com/" target="_blank" class="text-blue-600 underline">Firebase æ§åˆ¶å°</a> ä¸¦ç™»å…¥æ‚¨çš„ Google å¸³è™Ÿã€‚</li>
                        <li>é»æ“Šã€Œå»ºç«‹å°ˆæ¡ˆã€(Create a project)ã€‚</li>
                        <li>ç‚ºæ‚¨çš„å°ˆæ¡ˆå‘½å (ä¾‹å¦‚ï¼š`my-whiteboard-app`)ï¼Œç„¶å¾Œé»æ“Šã€Œç¹¼çºŒã€ã€‚</li>
                        <li>æ‚¨å¯ä»¥é¸æ“‡**é—œé–‰** "ç‚ºé€™å€‹å°ˆæ¡ˆå•Ÿç”¨ Google Analytics" (Enable Google Analytics)ï¼Œå› ç‚ºæ­¤å°ˆæ¡ˆç”¨ä¸åˆ°ã€‚é»æ“Šã€Œå»ºç«‹å°ˆæ¡ˆã€ã€‚</li>
                    </ol>
                </div>
    
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬äºŒæ­¥ï¼šåœ¨å°ˆæ¡ˆä¸­æ–°å¢ã€Œç¶²é æ‡‰ç”¨ã€ä¸¦å–å¾—è¨­å®šç¢¼</h3>
                    <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>å°ˆæ¡ˆå»ºç«‹å¾Œï¼Œåœ¨å°ˆæ¡ˆä¸»æ§å°é é¢ï¼Œé»æ“Šã€Œç¶²é ã€åœ–ç¤º (<code class="bg-gray-200 px-1 rounded">&lt;/&gt;</code>)ã€‚</li>
                        <li>ç‚ºæ‚¨çš„æ‡‰ç”¨ç¨‹å¼å–ä¸€å€‹æš±ç¨± (ä¾‹å¦‚ï¼š`ç™½æ¿å‰ç«¯`)ï¼Œç„¶å¾Œé»æ“Šã€Œè¨»å†Šæ‡‰ç”¨ç¨‹å¼ã€ã€‚</li>
                        <li>è¨»å†Šå¾Œï¼Œæ‚¨æœƒçœ‹åˆ°ã€Œå°‡ Firebase SDK æ–°å¢è‡³æ‚¨çš„æ‡‰ç”¨ç¨‹å¼ã€çš„ç•«é¢ã€‚è«‹æ‰¾åˆ° <code class="bg-gray-200 px-1 rounded">firebaseConfig</code> ç‰©ä»¶ã€‚</li>
                        <li><strong>(é—œéµæ­¥é©Ÿ)</strong> è¤‡è£½æ•´å€‹ <code class="bg-gray-200 px-1 rounded">const firebaseConfig = { ... };</code> ç¨‹å¼ç¢¼å€å¡Šã€‚</li>
                        <li>æ‰“é–‹ <code>whiteboard.html</code> æª”æ¡ˆï¼Œæ‰¾åˆ° <code>&lt;script type="module"&gt;</code> å€å¡Šï¼Œå°‡æ‚¨å‰›å‰›è¤‡è£½çš„å…§å®¹ï¼Œå®Œæ•´åœ°è²¼ä¸Šä¾†å–ä»£æ‰é è¨­çš„ä½”ä½ç¬¦ã€‚</li>
                    </ol>
                </div>
    
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬ä¸‰æ­¥ï¼šè¨­å®š Firestore è³‡æ–™åº«</h3>
                    <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>åœ¨ Firebase æ§åˆ¶å°å·¦å´é¸å–®ï¼Œé»æ“Šã€Œå»ºæ§‹ã€(Build) > ã€ŒFirestore Databaseã€ã€‚</li>
                        <li>é»æ“Šã€Œå»ºç«‹è³‡æ–™åº«ã€(Create database)ã€‚</li>
                        <li>é¸æ“‡ã€Œä»¥**æ¸¬è©¦æ¨¡å¼**é–‹å§‹ã€(Start in test mode)ï¼Œç„¶å¾Œé»æ“Šã€Œä¸‹ä¸€æ­¥ã€ã€‚</li>
                        <li>é¸æ“‡é›¢æ‚¨æœ€è¿‘çš„ Cloud Firestore ä½ç½® (ä¾‹å¦‚ï¼š`asia-east1` (å°ç£) æˆ– `asia-northeast1` (æ±äº¬))ï¼Œç„¶å¾Œé»æ“Šã€Œå•Ÿç”¨ã€ã€‚</li>
                    </ol>
                </div>
                
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬å››æ­¥ï¼šå•Ÿç”¨ã€ŒåŒ¿åç™»å…¥ã€</h3>
                     <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>åœ¨ Firebase æ§åˆ¶å°å·¦å´é¸å–®ï¼Œé»æ“Šã€Œå»ºæ§‹ã€(Build) > ã€ŒAuthenticationã€ã€‚</li>
                        <li>é»æ“Šã€Œé–‹å§‹ä½¿ç”¨ã€(Get started)ã€‚</li>
                        <li>åœ¨æ–°é é¢ä¸­ï¼Œé¸æ“‡ã€Œç™»å…¥æ–¹å¼ã€(Sign-in method) é ç±¤ã€‚</li>
                        <li>åœ¨ä¾›æ‡‰å•†æ¸…å–®ä¸­ï¼Œæ‰¾åˆ°ã€ŒåŒ¿åã€(Anonymous) ä¸¦é»æ“Šå®ƒã€‚</li>
                        <li>å°‡é–‹é—œè¨­å®šç‚ºã€Œå•Ÿç”¨ã€(Enable)ï¼Œç„¶å¾Œé»æ“Šã€Œå„²å­˜ã€ã€‚</li>
                    </ol>
                </div>

                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬äº”æ­¥ï¼šæ›´æ–°è³‡æ–™åº«å®‰å…¨è¦å‰‡ (é•·æœŸä½¿ç”¨)</h3>
                     <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>åœ¨ã€ŒFirestore Databaseã€é é¢ï¼Œé»æ“Šä¸Šæ–¹çš„ã€Œè¦å‰‡ã€(Rules) é ç±¤ã€‚</li>
                        <li>å°‡ç·¨è¼¯å™¨ä¸­ç¾æœ‰çš„æ‰€æœ‰æ–‡å­—åˆªé™¤ã€‚</li>
                        <li>è¤‡è£½ä¸‹æ–¹çš„ç¨‹å¼ç¢¼ï¼Œä¸¦å®Œæ•´è²¼åˆ°ç·¨è¼¯å™¨ä¸­ã€‚é€™å°‡å…è¨±æ‰€æœ‰å·²ç™»å…¥çš„ä½¿ç”¨è€…ï¼ˆåŒ…å«åŒ¿åç™»å…¥ï¼‰å­˜å–ç™½æ¿è³‡æ–™ï¼Œç¢ºä¿ç™½æ¿åœ¨30å¤©å¾Œä»å¯æ­£å¸¸ä½¿ç”¨ã€‚</li>
                        <li class="list-none">
                            <pre class="code-block"><code>rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /sessions/{sessionId} {
      // å…è¨±å·²ç™»å…¥ç”¨æˆ¶è®€å–ã€å»ºç«‹ã€æ›´æ–°ã€åˆªé™¤sessionæ–‡ä»¶
      allow read, create, update, delete: if request.auth != null;

      // å…è¨±å·²ç™»å…¥ç”¨æˆ¶æ“ä½œæ‰€æœ‰å­é›†åˆï¼ˆparticipants, canvasObjectsç­‰ï¼‰
      match /{document=**} {
        allow read, create, update, delete: if request.auth != null;
      }
    }
  }
}</code></pre>
                        </li>
                        <li>é»æ“Šã€Œç™¼å¸ƒã€(Publish) æŒ‰éˆ•ä¾†å„²å­˜æ‚¨çš„æ–°è¦å‰‡ã€‚</li>
                    </ol>
                </div>
            </div>
             <div class="text-xs text-gray-500 text-center pt-4 border-t">
                <p>å®Œæˆä»¥ä¸Šäº”å€‹æ­¥é©Ÿå¾Œï¼Œè«‹é‡æ–°æ•´ç† <code>whiteboard.html</code> é é¢å³å¯é–‹å§‹ä½¿ç”¨ï¼</p>
            </div>
        </div>
    </div>
    
    <!-- PDF Preview Modal -->
    <div id="pdf-preview-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl h-[90vh] flex flex-col">
            <div class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold">é¸æ“‡è¦æ’å…¥çš„ PDF é é¢</h2>
                <button id="close-pdf-modal" class="text-gray-500 hover:text-gray-800">&times;</button>
            </div>
            <div id="pdf-preview-grid" class="p-4 flex-grow overflow-y-auto grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                <!-- PDF pages will be rendered here -->
            </div>
            <div class="p-4 border-t flex justify-end">
                <button id="insert-pdf-pages-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700">æ’å…¥é¸å–é é¢</button>
            </div>
        </div>
    </div>
    
    <!-- Message Overlay -->
    <div id="message-overlay" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-60 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-sm text-center p-6 space-y-4">
            <p id="message-text" class="text-lg text-gray-800"></p>
            <button id="message-ok-btn" class="bg-blue-600 text-white px-8 py-2 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">ç¢ºå®š</button>
        </div>
    </div>

    <!-- Confirm Overlay -->
    <div id="confirm-overlay" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-60 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md text-center p-6 space-y-4">
            <div class="flex justify-center mb-4">
                <svg class="w-16 h-16 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
            </div>
            <h3 id="confirm-title" class="text-xl font-bold text-gray-800 mb-2"></h3>
            <p id="confirm-text" class="text-gray-600 mb-6"></p>
            <div class="flex space-x-3 justify-center">
                <button id="confirm-cancel-btn" class="px-6 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400">å–æ¶ˆ</button>
                <button id="confirm-ok-btn" class="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">ç¢ºèª</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500 mx-auto"></div>
            <p id="loading-text" class="mt-4 text-lg font-semibold">è™•ç†ä¸­...</p>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, addDoc, collection, onSnapshot, updateDoc, deleteDoc, runTransaction, serverTimestamp, getDocs, writeBatch, query, where } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-auth.js";

        // --- Custom Message Overlay ---
        function showMessage(message) {
            const overlay = document.getElementById('message-overlay');
            const text = document.getElementById('message-text');
            if (overlay && text) {
                text.textContent = message;
                overlay.classList.remove('hidden');
            } else {
                // Fallback to native alert if UI is not ready
                console.warn("showMessage UI not found, falling back to native alert.");
                alert(message);
            }
        }

        // --- Custom Confirm Overlay ---
        function showConfirm(title, message) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('confirm-overlay');
                const titleEl = document.getElementById('confirm-title');
                const textEl = document.getElementById('confirm-text');
                const okBtn = document.getElementById('confirm-ok-btn');
                const cancelBtn = document.getElementById('confirm-cancel-btn');

                if (overlay && titleEl && textEl && okBtn && cancelBtn) {
                    titleEl.textContent = title;
                    textEl.textContent = message;
                    overlay.classList.remove('hidden');

                    // Create one-time event listeners
                    const handleOk = () => {
                        overlay.classList.add('hidden');
                        okBtn.removeEventListener('click', handleOk);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve(true);
                    };

                    const handleCancel = () => {
                        overlay.classList.add('hidden');
                        okBtn.removeEventListener('click', handleOk);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve(false);
                    };

                    okBtn.addEventListener('click', handleOk);
                    cancelBtn.addEventListener('click', handleCancel);
                } else {
                    // Fallback to native confirm if UI is not ready
                    console.warn("showConfirm UI not found, falling back to native confirm.");
                    resolve(confirm(title + '\n\n' + message));
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Set up the 'OK' button listener for our custom message box
            const okBtn = document.getElementById('message-ok-btn');
            if (okBtn) {
                okBtn.addEventListener('click', () => {
                    const overlay = document.getElementById('message-overlay');
                    if(overlay) overlay.classList.add('hidden');
                });
            }
        });

        // --- DOM Elements ---
        const landingView = document.getElementById('landing-view');
        const whiteboardView = document.getElementById('whiteboard-view');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const setupModal = document.getElementById('setup-modal');

        // --- Global State ---
        let firebaseApp, db, auth;
        let sessionId, userRole;
        let currentPage = 1;
        const unsubscribes = [];
        let unsubscribePageObjects; // For page-specific objects listener
        let isLocked = false;
        let isCurrentUserIndividuallyLocked = false;
        let showAuthorNames = false;
        const participantDataMap = new Map(); // Map<uid, {name, role, isLockedByTeacher}>
        let isDrawing = false, isPanning = false, lastPointer = { x: 0, y: 0 };
        let touchStartTime = 0; // Track when first touch started
        let initialTouchCount = 0; // Track initial touch count
        let remoteUpdateGuard = false; // Prevent feedback loops
        const fabricObjects = new Map(); // Maps Firestore docId to Fabric object

        // Inactivity timer for students (30 minutes)
        let inactivityTimer = null;
        const INACTIVITY_TIMEOUT = 30 * 60 * 1000; // 30 minutes in milliseconds

        // --- Firebase Initialization ---
        // â–¼â–¼â–¼ è«‹åœ¨æ­¤è™•è²¼ä¸Šæ‚¨çš„ Firebase è¨­å®šç¢¼ â–¼â–¼â–¼
        const firebaseConfig = {
  apiKey: "AIzaSyB3VBGHvCanRIh3GcOOoWu2avkG2onMG68",
  authDomain: "whiteboard-d1d11.firebaseapp.com",
  projectId: "whiteboard-d1d11",
  storageBucket: "whiteboard-d1d11.firebasestorage.app",
  messagingSenderId: "258616814333",
  appId: "1:258616814333:web:19b0b900c1a74b8e76ac94"
        };
        // â–²â–²â–² è«‹åœ¨æ­¤è™•è²¼ä¸Šæ‚¨çš„ Firebase è¨­å®šç¢¼ â–²â–²â–²

        function initApp() {
            if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY") {
                setupModal.classList.remove('hidden');
                landingView.innerHTML = `<div class="p-8 bg-white rounded-lg shadow-xl text-center">
                    <h1 class="text-2xl font-bold text-red-600">è«‹å…ˆè¨­å®š Firebase</h1>
                    <p class="mt-2 text-gray-700">è«‹ä¾ç…§å½ˆå‡ºè¦–çª—çš„èªªæ˜ï¼Œåœ¨ç¨‹å¼ç¢¼ä¸­å®Œæˆè¨­å®šå¾Œï¼Œé‡æ–°æ•´ç†é é¢ã€‚</p>
                </div>`;
                return;
            }

            try {
                firebaseApp = initializeApp(firebaseConfig);
                db = getFirestore(firebaseApp);
                auth = getAuth(firebaseApp);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        // User is signed in anonymously.
                        console.log("Anonymous user signed in:", user.uid);
                    } else {
                        // User is signed out.
                        signInAnonymously(auth).catch(error => {
                            console.error("Anonymous sign-in failed:", error);
                            showMessage("ç„¡æ³•é€£æ¥åˆ°å¾Œç«¯æœå‹™ï¼Œè«‹æª¢æŸ¥æ‚¨çš„Firebaseè¨­å®šï¼Œç‰¹åˆ¥æ˜¯ç¢ºèªæ˜¯å¦å·²å•Ÿç”¨ã€ŒåŒ¿åç™»å…¥ã€ã€‚");
                        });
                    }
                });

                landingView.classList.remove('hidden');

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showMessage("Firebase è¨­å®šæ ¼å¼éŒ¯èª¤ï¼Œè«‹é‡æ–°è¨­å®šã€‚");
            }
        }

        // --- Session Management ---
        const TEACHER_PASSWORD = "tpet"; // æ•™å¸«å¯†ç¢¼

        // New teacher login flow
        document.getElementById('teacher-password-submit-btn').addEventListener('click', async () => {
            const inputPassword = document.getElementById('teacher-password').value.trim();
            if (inputPassword !== TEACHER_PASSWORD) {
                showMessage("âŒ å¯†ç¢¼éŒ¯èª¤ï¼\nè«‹è¼¸å…¥æ­£ç¢ºçš„æ•™å¸«å¯†ç¢¼ã€‚");
                return;
            }

            const step1Btn = document.getElementById('teacher-password-submit-btn');
            step1Btn.disabled = true;
            step1Btn.textContent = 'è¼‰å…¥ä¸­...';

            try {
                const dropdown = document.getElementById('existing-sessions-dropdown');
                dropdown.innerHTML = '<option value="">æ­£åœ¨è¼‰å…¥ç™½æ¿åˆ—è¡¨...</option>';
                
                const sessionsQuery = query(collection(db, "sessions"));
                const sessionsSnapshot = await getDocs(sessionsQuery);
                
                dropdown.innerHTML = '<option value="">-- è«‹é¸æ“‡æˆ–æ–¼ä¸‹æ–¹è¼¸å…¥æ–°ID --</option>';

                if (sessionsSnapshot.empty) {
                    const option = document.createElement('option');
                    option.textContent = 'ç›®å‰æ²’æœ‰ç¾å­˜ç™½æ¿';
                    option.disabled = true;
                    dropdown.appendChild(option);
                } else {
                    sessionsSnapshot.forEach(doc => {
                        const option = document.createElement('option');
                        option.value = doc.id;
                        option.textContent = doc.id;
                        dropdown.appendChild(option);
                    });
                }
                
                document.getElementById('teacher-login-step1').classList.add('hidden');
                document.getElementById('teacher-login-step2').classList.remove('hidden');

            } catch (error) {
                console.error("Error fetching existing sessions:", error);
                showMessage("è®€å–ç¾æœ‰ç™½æ¿åˆ—è¡¨æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚");
                step1Btn.disabled = false;
                step1Btn.textContent = 'ä¸‹ä¸€æ­¥';
            }
        });

        document.getElementById('enter-whiteboard-btn').addEventListener('click', async () => {
            const dropdownId = document.getElementById('existing-sessions-dropdown').value;
            const inputId = document.getElementById('session-id-teacher').value.trim();
            
            let sessionIdToUse = inputId || dropdownId;

            if (!sessionIdToUse) {
                sessionIdToUse = Math.random().toString(36).substring(2, 7).toUpperCase();
            }

            if (!auth.currentUser) {
                showMessage("ç„¡æ³•é©—è­‰ä½¿ç”¨è€…èº«ä»½ï¼Œè«‹é‡æ–°æ•´ç†é é¢å¾Œå†è©¦ä¸€æ¬¡ã€‚");
                return;
            }

            const sessionRef = doc(db, "sessions", sessionIdToUse);
            const sessionSnap = await getDoc(sessionRef);

            if (sessionSnap.exists()) {
                const takeOver = await showConfirm(
                    'ç™½æ¿å·²å­˜åœ¨',
                    `ç™½æ¿ID "${sessionIdToUse}" å·²è¢«ä½¿ç”¨ã€‚æ‚¨æ˜¯å¦è¦å–ä»£ç›®å‰çš„è€å¸«ä¸¦æ¥ç®¡é€™å€‹ç™½æ¿ï¼Ÿ`
                );
                if (takeOver) {
                    await updateDoc(sessionRef, { "metadata.ownerUid": auth.currentUser.uid });
                    enterWhiteboard(sessionIdToUse, "teacher", "è€å¸«");
                }
            } else {
                await setDoc(sessionRef, {
                    metadata: {
                        createdAt: serverTimestamp(),
                        isLocked: false,
                        ownerUid: auth.currentUser.uid,
                        showAuthorNames: false,
                        pageCount: 1
                    }
                });
                enterWhiteboard(sessionIdToUse, "teacher", "è€å¸«");
            }
        });

        // Logic for deleting a selected session from the landing page
        async function deleteSingleSession(idToDelete) {
            console.log(`[åˆªé™¤å–®ä¸€ç™½æ¿] é–‹å§‹åˆªé™¤ç™½æ¿ ID: ${idToDelete}`);
            showLoading(true, `æ­£åœ¨åˆªé™¤ç™½æ¿ ${idToDelete}...`);

            try {
                const deletePromises = [];

                // Delete all participants in the session
                const participantsRef = collection(db, "sessions", idToDelete, "participants");
                const participantsSnap = await getDocs(participantsRef);
                participantsSnap.forEach(doc => {
                    deletePromises.push(deleteDoc(doc.ref));
                });

                // Delete all canvasObjects in the session
                const objectsRef = collection(db, "sessions", idToDelete, "canvasObjects");
                const objectsSnap = await getDocs(objectsRef);
                objectsSnap.forEach(doc => {
                    deletePromises.push(deleteDoc(doc.ref));
                });

                await Promise.all(deletePromises);
                console.log(`[åˆªé™¤å–®ä¸€ç™½æ¿] ç™½æ¿ ${idToDelete} çš„å­é›†åˆéƒ½å·²åˆªé™¤`);

                // Delete the main session document
                const sessionRef = doc(db, "sessions", idToDelete);
                await deleteDoc(sessionRef);
                console.log(`[åˆªé™¤å–®ä¸€ç™½æ¿] ç™½æ¿ ${idToDelete} å·²å®Œå…¨åˆªé™¤`);

                showLoading(false);
                showMessage(`ç™½æ¿ "${idToDelete}" å·²æˆåŠŸåˆªé™¤ã€‚`);

            } catch (error) {
                console.error(`[åˆªé™¤å–®ä¸€ç™½æ¿] åˆªé™¤éç¨‹ç™¼ç”ŸéŒ¯èª¤ (ID: ${idToDelete}):`, error);
                showLoading(false);
                showMessage(`åˆªé™¤ç™½æ¿æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}`);
            }
        }

        document.getElementById('existing-sessions-dropdown').addEventListener('input', (e) => {
            const deleteBtn = document.getElementById('delete-selected-session-btn');
            if (e.target.value) {
                deleteBtn.classList.remove('hidden');
            } else {
                deleteBtn.classList.add('hidden');
            }
        });

        document.getElementById('delete-selected-session-btn').addEventListener('click', async () => {
            const dropdown = document.getElementById('existing-sessions-dropdown');
            const sessionIdToDelete = dropdown.value;

            if (!sessionIdToDelete) {
                showMessage("è«‹å…ˆå¾ä¸‹æ‹‰é¸å–®ä¸­é¸æ“‡ä¸€å€‹è¦åˆªé™¤çš„ç™½æ¿ã€‚");
                return;
            }

            const confirmed = await showConfirm(
                'âš ï¸ ç¢ºèªåˆªé™¤ç™½æ¿',
                `æ­¤å‹•ä½œå°‡æ°¸ä¹…åˆªé™¤ç™½æ¿ "${sessionIdToDelete}" çš„æ‰€æœ‰è³‡æ–™ï¼Œä¸”ç„¡æ³•å¾©åŸã€‚æ‚¨ç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ`
            );

            if (confirmed) {
                await deleteSingleSession(sessionIdToDelete);
                // Refresh the dropdown
                const optionToRemove = dropdown.querySelector(`option[value="${sessionIdToDelete}"]`);
                if(optionToRemove) {
                    optionToRemove.remove();
                }
                dropdown.value = ""; // Reset selection
                document.getElementById('delete-selected-session-btn').classList.add('hidden');
            }
        });

        document.getElementById('join-session-btn').addEventListener('click', async () => {
            const studentName = document.getElementById('student-name').value.trim();
            if (!studentName) {
                showMessage("âŒ è«‹è¼¸å…¥æ‚¨çš„å§“åã€‚");
                return;
            }

            let joinSessionId = document.getElementById('session-id-student').value.trim();
            if (!joinSessionId) {
                showMessage("âŒ è«‹è¼¸å…¥ç™½æ¿IDã€‚");
                return;
            }
            const sessionRef = doc(db, "sessions", joinSessionId);
            const sessionSnap = await getDoc(sessionRef);

            if (!sessionSnap.exists()) {
                showMessage(`âŒ ç™½æ¿ID "${joinSessionId}" ä¸å­˜åœ¨ï¼Œè«‹ç¢ºèªå¾Œå†è¼¸å…¥ã€‚`);
                return;
            }
            enterWhiteboard(joinSessionId, "student", studentName);
        });

        // Enter key support for teacher section
        document.getElementById('teacher-password').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('teacher-password-submit-btn').click();
            }
        });
        document.getElementById('session-id-teacher').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('enter-whiteboard-btn').click();
            }
        });

        // Enter key support for student section
        document.getElementById('student-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('join-session-btn').click();
            }
        });
        document.getElementById('session-id-student').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('join-session-btn').click();
            }
        });

        document.getElementById('show-setup-btn').addEventListener('click', () => {
            setupModal.classList.remove('hidden');
        });

        document.getElementById('close-setup-btn').addEventListener('click', () => {
            setupModal.classList.add('hidden');
        });

        async function enterWhiteboard(id, role, name) {
            sessionId = id;
            userRole = role;
            
            await setupParticipant(id, role, name);

            // NEW: Listen for current user's participant document deletion
            const currentUserParticipantRef = doc(db, "sessions", sessionId, "participants", auth.currentUser.uid);
            const unsubscribeCurrentUserParticipant = onSnapshot(currentUserParticipantRef, (docSnap) => {
                if (!docSnap.exists()) {
                    // Current user's participant document was deleted (kicked)
                    unsubscribes.forEach(unsub => unsub()); // Clean up all listeners
                    unsubscribes.length = 0;
                    window.location.reload();
                }
            });
            unsubscribes.push(unsubscribeCurrentUserParticipant);

            landingView.classList.add('hidden');
            whiteboardView.classList.remove('hidden');
            document.getElementById('session-id-display').textContent = sessionId;

            if (userRole === 'teacher') {
                document.getElementById('teacher-tools').classList.remove('hidden');
            } else if (userRole === 'student') {
                const studentNameContainer = document.getElementById('student-name-display-container');
                const studentNameEl = document.getElementById('student-name-display');
                studentNameEl.textContent = name;
                studentNameContainer.classList.remove('hidden');
            }
            
            initWhiteboard();
            listenToSessionChanges();
        }

        async function setupParticipant(sessionId, userRole, userName) {
            if (!auth.currentUser) {
                console.error("User not authenticated, cannot set up participant.");
                return;
            }
            const participantRef = doc(db, "sessions", sessionId, "participants", auth.currentUser.uid);
            await setDoc(participantRef, {
                name: userName,
                role: userRole,
                joinedAt: serverTimestamp(),
                isLockedByTeacher: false // Add this
            });

            window.addEventListener('beforeunload', () => {
                // This is best-effort, might not run on all browsers/situations
                deleteDoc(participantRef);
            });
        }
        
        // --- Page Management --- 
        function renderPagesUI(pageCount, activePage) {
            const pagesToolbar = document.getElementById('pages-toolbar');
            pagesToolbar.innerHTML = ''; // Clear existing

            for (let i = 1; i <= pageCount; i++) {
                const pageBtnContainer = document.createElement('div'); // Use a container
                pageBtnContainer.className = 'relative';

                const pageBtn = document.createElement('button');
                pageBtn.className = `w-16 h-10 rounded-md flex items-center justify-center text-lg font-bold border-2`;
                pageBtn.textContent = i;
                if (i === activePage) {
                    pageBtn.classList.add('bg-blue-500', 'border-blue-300');
                } else {
                    pageBtn.classList.add('bg-gray-700', 'border-gray-600', 'hover:bg-gray-600');
                }
                pageBtn.addEventListener('click', () => switchPage(i));
                
                pageBtnContainer.appendChild(pageBtn);

                if (userRole === 'teacher') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'absolute -top-2 -right-2 w-6 h-6 bg-red-600 text-white rounded-full flex items-center justify-center text-sm font-bold border-2 border-white hover:bg-red-700 z-10';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.title = `åˆªé™¤ç¬¬ ${i} é `;
                    deleteBtn.dataset.page = i;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent page switch
                        const pageToDelete = parseInt(e.currentTarget.dataset.page, 10);
                        deletePage(pageToDelete);
                    });
                    pageBtnContainer.appendChild(deleteBtn);
                }
                
                pagesToolbar.appendChild(pageBtnContainer);
            }

            if (userRole === 'teacher') {
                const addPageBtn = document.createElement('button');
                addPageBtn.className = 'w-16 h-10 rounded-md flex items-center justify-center text-2xl font-bold bg-green-600 hover:bg-green-700 border-2 border-green-500 mt-2';
                addPageBtn.textContent = '+';
                addPageBtn.title = 'æ–°å¢ç•«å¸ƒ';
                addPageBtn.addEventListener('click', addPage);
                pagesToolbar.appendChild(addPageBtn);
            }
        }

        async function addPage() {
            const sessionRef = doc(db, "sessions", sessionId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(sessionRef);
                    if (!sfDoc.exists()) throw "Document does not exist!";
                    const newPageCount = (sfDoc.data().metadata.pageCount || 1) + 1;
                    transaction.update(sessionRef, { "metadata.pageCount": newPageCount });
                });
            } catch (e) {
                console.error("Add page transaction failed: ", e);
            }
        }

        function switchPage(pageNum) {
            if (pageNum === currentPage) return;
            resetInactivityTimer(); // Reset timer on user activity
            currentPage = pageNum;
            console.log(`Switched to page ${currentPage}`);
            listenToPageObjects(pageNum);
            // Update UI highlighting without re-fetching page count
            const pagesToolbar = document.getElementById('pages-toolbar');
            const buttons = pagesToolbar.querySelectorAll('button');
            buttons.forEach(btn => {
                const isPageNumBtn = !btn.textContent.includes('+');
                if (!isPageNumBtn) return;

                btn.classList.remove('bg-blue-500', 'border-blue-300', 'bg-gray-700', 'border-gray-600', 'hover:bg-gray-600');
                if (parseInt(btn.textContent) === pageNum) {
                    btn.classList.add('bg-blue-500', 'border-blue-300');
                } else {
                    btn.classList.add('bg-gray-700', 'border-gray-600', 'hover:bg-gray-600');
                }
            });
        }

        // --- Firestore Real-time Sync --- 
        function listenToPageObjects(pageNum) {
            // Unsubscribe from the old page's listener if it exists
            if (unsubscribePageObjects) {
                unsubscribePageObjects();
            }

            // Clear canvas and local object map for the new page
            canvas.clear();
            fabricObjects.clear();

            const objectsRef = collection(db, "sessions", sessionId, "canvasObjects");
            const q = query(objectsRef, where("page", "==", pageNum));

            unsubscribePageObjects = onSnapshot(q, (snapshot) => {
                const changes = snapshot.docChanges();
                console.log(`[Firestore] Received ${changes.length} changes`);

                changes.forEach((change) => {
                    const docId = change.doc.id;
                    const objectData = change.doc.data();

                    if (change.type === "added") {
                        if (!fabricObjects.has(docId)) {
                            console.log(`ğŸ“¥ [Firestore] Receiving new object from other user (docId: ${docId})`, {
                                type: objectData.type,
                                authorUid: objectData.authorUid,
                                page: objectData.page,
                                currentUserPage: currentPage
                            });

                            const dataToEnliven = objectData.data;

                            // Handle path deserialization for paths
                            if (dataToEnliven.type === 'path') {
                                if (typeof dataToEnliven.path === 'string') {
                                    console.log(`[Firestore] ğŸ“ Parsing path JSON string for drawing sync`);
                                    try {
                                        dataToEnliven.path = JSON.parse(dataToEnliven.path);
                                        console.log(`[Firestore] âœ… Path parsed successfully, ${dataToEnliven.path.length} commands`);
                                    } catch (err) {
                                        console.error(`[Firestore] âŒ Failed to parse path:`, err);
                                    }
                                } else if (Array.isArray(dataToEnliven.path)) {
                                    console.log(`[Firestore] â„¹ï¸ Path already an array (${dataToEnliven.path.length} commands)`);
                                } else {
                                    console.error(`[Firestore] âŒ Path data missing or invalid type:`, typeof dataToEnliven.path);
                                }

                                // IMPORTANT: Ensure fill is null for stroke-only paths
                                // This prevents the black triangle appearance
                                if (!dataToEnliven.fill) {
                                    dataToEnliven.fill = null;
                                }

                                // Log path details for debugging
                                console.log('[Firestore] ğŸ“ Received path details:', {
                                    stroke: dataToEnliven.stroke,
                                    strokeWidth: dataToEnliven.strokeWidth,
                                    fill: dataToEnliven.fill,
                                    hasPath: !!dataToEnliven.path
                                });
                            }

                            remoteUpdateGuard = true;
                            fabric.util.enlivenObjects([dataToEnliven], function (objects) {
                                const fabricObj = objects[0];
                                if (!fabricObj) {
                                    console.error('[Firestore] âŒ Failed to enliven object');
                                    remoteUpdateGuard = false;
                                    return;
                                }
                                fabricObj.docId = docId;
                                fabricObj.authorUid = objectData.authorUid;
                                fabricObj.page = objectData.page;
                                setupNewObject(fabricObj);
                                fabricObjects.set(docId, fabricObj);
                                if (showAuthorNames && fabricObj.authorUid) {
                                    addAuthorNameText(fabricObj);
                                }
                                remoteUpdateGuard = false;
                                canvas.requestRenderAll();
                                console.log(`âœ… [Firestore] Successfully added and rendered iPad drawing on this canvas`, {
                                    docId: docId,
                                    type: fabricObj.type
                                });
                            });
                        } else {
                            console.log(`[Firestore] â­ï¸ Object ${docId} already exists locally, skipping`);
                        }
                    }
                    if (change.type === "modified") {
                        const existingObj = fabricObjects.get(docId);
                        if (existingObj) {
                            const dataToSet = objectData.data;

                            // Handle path deserialization for paths
                            if (dataToSet.type === 'path') {
                                if (typeof dataToSet.path === 'string') {
                                    try {
                                        dataToSet.path = JSON.parse(dataToSet.path);
                                        console.log(`[Firestore] ğŸ“ Path updated: ${dataToSet.path.length} commands`);
                                    } catch (err) {
                                        console.error(`[Firestore] âŒ Failed to parse updated path:`, err);
                                    }
                                } else if (!Array.isArray(dataToSet.path)) {
                                    console.error(`[Firestore] âŒ Updated path data invalid:`, typeof dataToSet.path);
                                }

                                // IMPORTANT: Ensure fill is null for stroke-only paths
                                if (!dataToSet.fill) {
                                    dataToSet.fill = null;
                                }
                            }

                            console.log(`[Firestore] âœ… Updating object ${docId}:`, {
                                type: dataToSet.type,
                                position: `(${dataToSet.left?.toFixed(0)}, ${dataToSet.top?.toFixed(0)})`,
                                scale: `(${dataToSet.scaleX?.toFixed(2)}, ${dataToSet.scaleY?.toFixed(2)})`,
                                angle: dataToSet.angle?.toFixed(0)
                            });

                            // Temporarily enable remote update guard to prevent echo
                            remoteUpdateGuard = true;

                            // Update object properties
                            existingObj.set(dataToSet);
                            existingObj.setCoords();
                            existingObj.authorUid = objectData.authorUid;

                            // Re-apply permissions
                            applyObjectPermissions(existingObj);

                            // Update author name text if visible
                            if (showAuthorNames && existingObj.authorUid) {
                                removeAuthorNameText(existingObj);
                                addAuthorNameText(existingObj);
                            }

                            // Mark as dirty to ensure it re-renders
                            existingObj.dirty = true;

                            // Re-enable updates
                            remoteUpdateGuard = false;

                            // Force immediate render for this change
                            canvas.requestRenderAll();
                        } else {
                            console.warn(`[Firestore] Object ${docId} not found in local map`);
                        }
                    }
                    if (change.type === "removed") {
                        const objToRemove = fabricObjects.get(docId);
                        if (objToRemove) {
                            console.log(`[Firestore] Removing object: ${docId}`);
                            remoteUpdateGuard = true;
                            removeAuthorNameText(objToRemove);
                            canvas.remove(objToRemove);
                            fabricObjects.delete(docId);
                            remoteUpdateGuard = false;
                            canvas.requestRenderAll();
                        }
                    }
                });

                // Final refresh to ensure all changes are visible
                setTimeout(() => {
                    if (canvas) {
                        canvas.forEachObject(obj => {
                            obj.setCoords();
                        });
                        canvas.requestRenderAll();
                        console.log('[Firestore] Final refresh complete');
                    }
                }, 100);
            });
            unsubscribes.push(unsubscribePageObjects);
        }

        function listenToSessionChanges() {
            // Listener for metadata (e.g., lock state, page count)
            const metadataRef = doc(db, "sessions", sessionId);
            const unsubscribeMetadata = onSnapshot(metadataRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data().metadata;
                    if (data.isLocked !== isLocked) {
                        handleLockState(data.isLocked);
                    }
                    // If another teacher takes over, this client is forced to leave.
                    if (userRole === 'teacher' && data.ownerUid && data.ownerUid !== auth.currentUser.uid) {
                                                            unsubscribes.forEach(unsub => unsub());
                                                            unsubscribes.length = 0;
                                                            window.location.reload();                        return;
                    }
            
                    // Handle showAuthorNames state change
                    if (data.showAuthorNames !== showAuthorNames) {
                        showAuthorNames = data.showAuthorNames;
                        canvas.forEachObject(obj => {
                            if (obj.authorUid) {
                                if (showAuthorNames) {
                                    addAuthorNameText(obj);
                                } else {
                                    removeAuthorNameText(obj);
                                }
                            }
                        });
                        canvas.requestRenderAll();
                    }

                    // Handle page count change
                    const pageCount = data.pageCount || 1;
                    renderPagesUI(pageCount, currentPage);

                } else {
                                                    // Session was deleted by the teacher
                                                    window.location.reload();                }
            });
            unsubscribes.push(unsubscribeMetadata);

            // Listener for participants
            const participantsRef = collection(db, "sessions", sessionId, "participants");
            const unsubscribeParticipants = onSnapshot(participantsRef, (snapshot) => {
                let studentCount = 0;
                participantDataMap.clear();
                snapshot.forEach(doc => {
                    const participant = { uid: doc.id, ...doc.data() };
                    participantDataMap.set(doc.id, participant);
                    if (participant.role === 'student') {
                        studentCount++;
                    }
                });
                document.getElementById('participant-display').textContent = `å­¸ç”Ÿäººæ•¸: ${studentCount}`;

                // Check if current user's individual lock state has changed
                const currentParticipantData = participantDataMap.get(auth.currentUser.uid);
                if (userRole === 'student' && currentParticipantData) {
                    const newIndividualLockState = currentParticipantData.isLockedByTeacher;
                    if (newIndividualLockState !== isCurrentUserIndividuallyLocked) {
                        isCurrentUserIndividuallyLocked = newIndividualLockState; // Update tracker
                        // Re-evaluate UI based on current global lock state (which will now consider individual lock)
                        handleLockState(isLocked); // Pass the current global lock state
                    }
                }

                // If showing names, refresh them
                if (showAuthorNames) {
                    canvas.forEachObject(obj => {
                        if (obj.authorUid) {
                            removeAuthorNameText(obj); // Remove old text
                            addAuthorNameText(obj);    // Add new text
                        }
                    });
                    canvas.requestRenderAll();
                }
                // Re-render participant list if modal is open
                if (!document.getElementById('participant-list-modal').classList.contains('hidden')) {
                    renderParticipantList();
                }
            });
            unsubscribes.push(unsubscribeParticipants);

            // Initial listener for page 1 objects
            listenToPageObjects(1);
        }

        // --- Whiteboard Initialization ---
        let canvas, activeTool = 'select';

        function initWhiteboard() {
            canvas = new fabric.Canvas('whiteboard-canvas', {
                width: window.innerWidth,
                height: window.innerHeight,
                fireRightClick: true,
                stopContextMenu: true,
                backgroundColor: '#f8fafc', // gray-50
                enableRetinaScaling: true,
                allowTouchScrolling: true, // Changed to true to support iPad drawing
                selection: true, // Enable multi-select box for select mode (default)
                isDrawingMode: false
            });

            // Initialize free drawing brush for iPad/touch devices
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
            canvas.freeDrawingBrush.color = '#000000';
            canvas.freeDrawingBrush.width = 2;

            console.log('[initWhiteboard] Canvas initialized', {
                width: canvas.width,
                height: canvas.height,
                isDrawingMode: canvas.isDrawingMode
            });

            window.addEventListener('resize', resizeCanvas);

            // Paste image from clipboard
            window.addEventListener('paste', (e) => {
                if (e.clipboardData) {
                    const items = e.clipboardData.items;
                    if (items) {
                        for (let i = 0; i < items.length; i++) {
                            if (items[i].type.indexOf('image') !== -1) {
                                const blob = items[i].getAsFile();
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    addImageToCanvas(event.target.result);
                                };
                                reader.readAsDataURL(blob);
                            }
                        }
                    }
                }
            });

            // --- Zoom Control Logic ---
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomLabel = document.getElementById('zoom-label');
            const updateZoomUI = () => {
                if (!canvas) return;
                const zoom = canvas.getZoom();
                if (zoomSlider) zoomSlider.value = zoom;
                if (zoomLabel) zoomLabel.textContent = `${Math.round(zoom * 100)}%`;
            };
            
            // Pan and Zoom
            canvas.on('mouse:wheel', function(opt) {
                resetInactivityTimer(); // Reset timer on user activity
                const delta = opt.e.deltaY;
                let zoom = canvas.getZoom();
                zoom *= 0.999 ** delta;
                if (zoom > 20) zoom = 20;
                if (zoom < 0.01) zoom = 0.01;
                canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
                opt.e.preventDefault();
                opt.e.stopPropagation();
                updateZoomUI(); // Update slider and label
            });

            canvas.on('mouse:down', function(opt) {
                const evt = opt.e;
                resetInactivityTimer(); // Reset timer on user activity

                // Track touch events for improved two-finger detection
                if (evt.touches) {
                    const currentTime = Date.now();
                    const touchCount = evt.touches.length;

                    // Reset tracking if it's been too long since last touch (>300ms)
                    if (currentTime - touchStartTime > 300) {
                        initialTouchCount = 0;
                        touchStartTime = 0;
                    }

                    // Check for two-finger touch gesture
                    if (touchCount === 2) {
                        isPanning = true;
                        this.lastDist = Math.hypot(evt.touches[0].clientX - evt.touches[1].clientX, evt.touches[0].clientY - evt.touches[1].clientY);
                        lastPointer = {
                            x: (evt.touches[0].clientX + evt.touches[1].clientX) / 2,
                            y: (evt.touches[0].clientY + evt.touches[1].clientY) / 2
                        };
                        canvas.selection = false;
                        evt.preventDefault();
                        console.log('[Touch] é›™æŒ‡ç¸®æ”¾æ¨¡å¼å·²å•Ÿå‹•');
                        return;
                    }

                    // Track first touch timing
                    if (touchCount === 1 && initialTouchCount === 0) {
                        initialTouchCount = 1;
                        touchStartTime = currentTime;
                    }
                }

                // IMPORTANT: If in drawing mode (pen tool), let Fabric.js handle it natively
                // Don't interfere with Fabric's internal touch/mouse handlers for drawing
                if (canvas.isDrawingMode) {
                    console.log('[mouse:down] Drawing mode active, letting Fabric handle it');
                    return;
                }

                // Pan mode: if pan tool is active OR Alt key/Right-click (but not for touch)
                if (activeTool === 'pan' && evt.touches && evt.touches.length === 1) {
                    // Pan mode with single touch
                    isPanning = true;
                    lastPointer = { x: evt.touches[0].clientX, y: evt.touches[0].clientY };
                    canvas.selection = false;
                    this.setCursor('grabbing');
                    return;
                } else if (activeTool === 'pan' && !evt.touches) {
                    // Pan mode with mouse
                    isPanning = true;
                    lastPointer = { x: evt.clientX, y: evt.clientY };
                    canvas.selection = false;
                    this.setCursor('grabbing');
                    return;
                } else if (!evt.touches && (evt.altKey === true || opt.button === 2)) {
                    // Alt key or Right-click pan (mouse only)
                    isPanning = true;
                    lastPointer = { x: evt.clientX, y: evt.clientY };
                    canvas.selection = false;
                    this.setCursor('grabbing');
                    return;
                }

                // For shape drawing tools (rect, circle) - not select/pan mode and not pen mode
                if (activeTool !== 'select' && activeTool !== 'pan' && !canvas.isDrawingMode) {
                    startDrawing(opt);
                }
                // Note: When activeTool is 'select' and the user clicks/taps,
                // Fabric.js will automatically handle object selection and marquee selection
            });

            canvas.on('mouse:move', function(opt) {
                const e = opt.e;
                resetInactivityTimer(); // Reset timer on user activity

                // Detect if second finger joins during move (improved iPad support)
                if (e.touches && e.touches.length === 2 && !isPanning && initialTouchCount === 1) {
                    const currentTime = Date.now();
                    // If within 300ms of first touch, activate pinch zoom
                    if (touchStartTime > 0 && currentTime - touchStartTime < 300) {
                        isPanning = true;
                        this.lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                        lastPointer = {
                            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                        };
                        canvas.selection = false;
                        canvas.discardActiveObject();
                        canvas.requestRenderAll();
                        console.log('[Touch] é›™æŒ‡ç¸®æ”¾æ¨¡å¼å·²å•Ÿå‹• (ç§»å‹•æ™‚åµæ¸¬)');
                        return;
                    }
                }

                // Handle panning gestures
                if (isPanning) {
                    if (e.touches && e.touches.length === 2) { // Touch gesture move
                        const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                        const newPointer = {
                            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                        };

                        // Zoom
                        let zoom = canvas.getZoom();
                        zoom *= newDist / this.lastDist;
                        if (zoom > 20) zoom = 20;
                        if (zoom < 0.01) zoom = 0.01;
                        canvas.zoomToPoint({ x: newPointer.x, y: newPointer.y }, zoom);
                        updateZoomUI(); // Update slider and label

                        // Pan
                        const vpt = canvas.viewportTransform;
                        vpt[4] += newPointer.x - lastPointer.x;
                        vpt[5] += newPointer.y - lastPointer.y;
                        canvas.requestRenderAll();

                        this.lastDist = newDist;
                        lastPointer = newPointer;
                    } else if (e.touches && e.touches.length === 1) { // Single touch pan move
                        const vpt = canvas.viewportTransform;
                        vpt[4] += e.touches[0].clientX - lastPointer.x;
                        vpt[5] += e.touches[0].clientY - lastPointer.y;
                        canvas.requestRenderAll();
                        lastPointer = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    } else if (!e.touches) { // Mouse pan move
                        const vpt = canvas.viewportTransform;
                        vpt[4] += e.clientX - lastPointer.x;
                        vpt[5] += e.clientY - lastPointer.y;
                        canvas.requestRenderAll();
                        lastPointer = { x: e.clientX, y: e.clientY };
                    }
                    return;
                }

                // If in drawing mode (pen tool), let Fabric.js handle it
                if (canvas.isDrawingMode) {
                    return;
                }

                // Handle shape drawing (rect, circle)
                continueDrawing(opt);
            });

            canvas.on('mouse:up', function(opt) {
                const wasPanning = isPanning;

                // Reset touch tracking based on remaining touches
                const evt = opt.e;
                if (!evt.touches || evt.touches.length === 0) {
                    // All fingers lifted - reset everything
                    isPanning = false;
                    touchStartTime = 0;
                    initialTouchCount = 0;
                } else if (evt.touches.length === 1) {
                    // One finger remains - reset for potential new gesture
                    isPanning = false;
                    touchStartTime = Date.now();
                    initialTouchCount = 1;
                } else {
                    // Still 2+ fingers - keep panning
                    isPanning = true;
                }

                // If in drawing mode (pen tool), let Fabric.js handle it
                // The path:created event will fire automatically when drawing is complete
                if (canvas.isDrawingMode) {
                    return;
                }

                // Finalize shape drawing (rect, circle)
                stopDrawing();

                // For shape drawing tools, ensure the canvas returns to a non-selecting state
                if (['rect', 'circle'].includes(activeTool)) {
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();
                }

                // Only enable group selection if the tool is 'select'
                canvas.selection = (activeTool === 'select');
                console.log(`[mouse:up] Set canvas.selection = ${canvas.selection}, activeTool = ${activeTool}`);

                // Reset cursor to default for the active tool
                if (activeTool === 'pan') {
                    this.setCursor('grab');
                } else if (activeTool === 'select') {
                    this.setCursor('default');
                } else {
                    this.setCursor('crosshair');
                }
            });

            // Object modification listener (fired when user finishes modifying an object)
            canvas.on('object:modified', async function(e) {
                resetInactivityTimer(); // Reset timer on user activity

                if (remoteUpdateGuard || !e.target) {
                    console.log('[object:modified] Skipped - remoteUpdateGuard');
                    return;
                }

                const updatedObject = e.target;

                // IMPORTANT: Handle activeSelection (multi-select group)
                if (updatedObject.type === 'activeSelection') {
                    const objects = updatedObject.getObjects();
                    console.log(`ğŸ“¦ [object:modified] Multi-select modified: ${objects.length} objects`);

                    // Temporarily discard the active selection to get absolute coordinates
                    // This converts relative group coordinates to absolute canvas coordinates
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();

                    console.log(`ğŸ“¦ [object:modified] Active selection discarded, objects now have absolute coords`);

                    // Now process each object with their updated absolute coordinates
                    for (const innerObj of objects) {
                        if (!innerObj.docId) {
                            console.warn(`[object:modified] Skipping object without docId`);
                            continue;
                        }

                        // Permission check for each object
                        if (userRole === 'student') {
                            if (innerObj.authorUid !== auth.currentUser.uid) {
                                console.log(`[object:modified] Student skipping object from another user`);
                                continue;
                            }
                            if (isLocked) {
                                console.log(`[object:modified] Student is locked`);
                                continue;
                            }
                        }

                        // After discarding the selection, objects now have absolute coordinates
                        console.log(`ğŸ“¤ [object:modified] Object absolute position:`, {
                            docId: innerObj.docId,
                            type: innerObj.type,
                            position: `(${innerObj.left?.toFixed(0)}, ${innerObj.top?.toFixed(0)})`,
                            scale: `(${innerObj.scaleX?.toFixed(2)}, ${innerObj.scaleY?.toFixed(2)})`,
                            angle: innerObj.angle?.toFixed(0)
                        });

                        const objectRef = doc(db, "sessions", sessionId, "canvasObjects", innerObj.docId);
                        try {
                            // Get object data with absolute coordinates
                            const objData = innerObj.toObject();

                            if (innerObj.type === 'path' && Array.isArray(objData.path)) {
                                objData.path = JSON.stringify(objData.path);
                            }

                            await updateDoc(objectRef, { data: objData });
                            console.log(`âœ… [object:modified] Successfully updated ${innerObj.docId} with absolute coords`);

                            if (showAuthorNames && innerObj.authorNameText) {
                                removeAuthorNameText(innerObj);
                                addAuthorNameText(innerObj);
                            }
                        } catch (error) {
                            console.error(`âŒ [object:modified] Error updating object ${innerObj.docId}:`, error);
                        }
                    }

                    // Re-select the objects to restore the selection
                    if (objects.length > 0) {
                        const selection = new fabric.ActiveSelection(objects, {
                            canvas: canvas
                        });
                        canvas.setActiveObject(selection);
                        canvas.requestRenderAll();
                        console.log(`ğŸ“¦ [object:modified] Re-selected ${objects.length} objects`);
                    }

                    return;
                }

                // Single object modification
                if (!updatedObject.docId) {
                    console.log('[object:modified] Skipped - no docId');
                    return;
                }

                // Permission check: Teachers can modify all objects, students can only modify their own
                if (userRole === 'student') {
                    if (updatedObject.authorUid !== auth.currentUser.uid) {
                        console.warn('âŒ [object:modified] Student cannot modify object created by another user', {
                            objectAuthorUid: updatedObject.authorUid,
                            currentUserUid: auth.currentUser.uid
                        });
                        return;
                    }
                    if (isLocked) {
                        console.warn('ğŸ”’ [object:modified] Student is locked');
                        return;
                    }
                }

                const objectRef = doc(db, "sessions", sessionId, "canvasObjects", updatedObject.docId);

                try {
                    const objData = updatedObject.toObject();
                    if (updatedObject.type === 'path' && Array.isArray(objData.path)) {
                        objData.path = JSON.stringify(objData.path);
                    }

                    console.log(`[object:modified] ğŸ“¤ Saving to Firestore (${userRole} modifying object):`, {
                        docId: updatedObject.docId,
                        type: updatedObject.type,
                        position: `(${objData.left?.toFixed(0)}, ${objData.top?.toFixed(0)})`,
                        scale: `(${objData.scaleX?.toFixed(2)}, ${objData.scaleY?.toFixed(2)})`,
                        angle: objData.angle?.toFixed(0),
                        isOwner: updatedObject.authorUid === auth.currentUser.uid
                    });

                    await updateDoc(objectRef, { data: objData });

                    console.log(`[object:modified] âœ… Successfully saved ${updatedObject.docId}`);

                    // Update author name text position if visible
                    if (showAuthorNames && updatedObject.authorNameText) {
                        removeAuthorNameText(updatedObject);
                        addAuthorNameText(updatedObject);
                    }
                } catch (error) {
                    console.error(`[object:modified] âŒ Error updating object:`, error);
                }
            });

            // Additional events for real-time updates during manipulation
            let scalingTimeout = null;
            let movingTimeout = null;
            let rotatingTimeout = null;

            // Update during scaling
            canvas.on('object:scaling', function(e) {
                if (remoteUpdateGuard) return;
                if (!e.target) return;

                const obj = e.target;

                // Skip activeSelection - handled in object:modified
                if (obj.type === 'activeSelection') {
                    return;
                }

                // Single object scaling
                if (!obj.docId) {
                    return;
                }

                // Permission check: Teachers can modify all objects, students can only modify their own
                if (userRole === 'student') {
                    if (obj.authorUid !== auth.currentUser.uid) return;
                    if (isLocked) return;
                }

                // Update author name position if visible
                if (showAuthorNames && obj.authorNameText) {
                    removeAuthorNameText(obj);
                    addAuthorNameText(obj);
                }

                // Debounce the Firestore update
                clearTimeout(scalingTimeout);
                scalingTimeout = setTimeout(() => {
                    updateObjectInFirestore(obj);
                }, 200);
            });

            // Update during moving
            canvas.on('object:moving', function(e) {
                if (remoteUpdateGuard) return;
                if (!e.target) return;

                const obj = e.target;

                // IMPORTANT: Skip activeSelection (multi-select group)
                // Multi-select coordinates are handled in object:modified event
                if (obj.type === 'activeSelection') {
                    return;
                }

                // Single object movement
                // Critical check: Ensure object has docId for Firestore sync
                if (!obj.docId) {
                    console.warn('âš ï¸ [object:moving] Object missing docId - cannot sync to other devices!', {
                        objectType: obj.type,
                        hasAuthorUid: !!obj.authorUid,
                        objectsInMap: fabricObjects.size
                    });
                    return;
                }

                // Permission check: Teachers can modify all objects, students can only modify their own
                if (userRole === 'student') {
                    if (obj.authorUid !== auth.currentUser.uid) {
                        console.warn('âŒ [object:moving] Student cannot modify object created by another user', {
                            objectAuthorUid: obj.authorUid,
                            currentUserUid: auth.currentUser.uid
                        });
                        return;
                    }
                    if (isLocked) {
                        console.warn('ğŸ”’ [object:moving] Student is locked');
                        return;
                    }
                }

                console.log('ğŸ–±ï¸ [object:moving] User can move this object', {
                    docId: obj.docId,
                    type: obj.type,
                    position: `(${obj.left?.toFixed(0)}, ${obj.top?.toFixed(0)})`,
                    userRole: userRole,
                    isOwner: obj.authorUid === auth.currentUser.uid
                });

                // Update author name position if visible
                if (showAuthorNames && obj.authorNameText) {
                    removeAuthorNameText(obj);
                    addAuthorNameText(obj);
                }

                // Debounce the Firestore update
                clearTimeout(movingTimeout);
                movingTimeout = setTimeout(() => {
                    console.log('ğŸ“¤ [object:moving] Sending update to Firestore:', obj.docId);
                    updateObjectInFirestore(obj);
                }, 200);
            });

            // Update during rotating
            canvas.on('object:rotating', function(e) {
                if (remoteUpdateGuard) return;
                if (!e.target) return;

                const obj = e.target;

                // Skip activeSelection - handled in object:modified
                if (obj.type === 'activeSelection') {
                    return;
                }

                // Single object rotation
                if (!obj.docId) {
                    return;
                }

                // Permission check: Teachers can modify all objects, students can only modify their own
                if (userRole === 'student') {
                    if (obj.authorUid !== auth.currentUser.uid) return;
                    if (isLocked) return;
                }

                // Update author name position if visible
                if (showAuthorNames && obj.authorNameText) {
                    removeAuthorNameText(obj);
                    addAuthorNameText(obj);
                }

                // Debounce the Firestore update
                clearTimeout(rotatingTimeout);
                rotatingTimeout = setTimeout(() => {
                    updateObjectInFirestore(obj);
                }, 200);
            });
            
            // Handle path creation from drawing mode
            canvas.on('path:created', async function(e) {
                console.log('âœ… [path:created] Event triggered', {
                    hasPath: !!e.path,
                    remoteUpdateGuard: remoteUpdateGuard,
                    userRole: userRole,
                    isLocked: isLocked,
                    isDrawingMode: canvas.isDrawingMode,
                    activeTool: activeTool
                });

                if (remoteUpdateGuard) {
                    console.log('[path:created] â­ï¸ Skipped - remoteUpdateGuard is true (remote update in progress)');
                    return;
                }

                if (!e.path) {
                    console.warn('[path:created] âŒ No path object in event');
                    return;
                }

                const newPath = e.path;

                // CRITICAL: Set fill to null to prevent black triangle appearance
                // Pen strokes should only have stroke, no fill
                newPath.set({
                    fill: null
                });

                console.log('[path:created] ğŸ¨ Path properties set:', {
                    stroke: newPath.stroke,
                    strokeWidth: newPath.strokeWidth,
                    fill: newPath.fill
                });

                // Set authorUid immediately for the path
                if (!newPath.authorUid && auth.currentUser) {
                    newPath.authorUid = auth.currentUser.uid;
                    console.log('[path:created] âœï¸ Set authorUid:', auth.currentUser.uid);
                }

                // Save to Firestore - each stroke is a separate object
                await addObjectToFirestore(newPath);

                console.log('[path:created] âœ… Path saved as individual object', {
                    hasDocId: !!newPath.docId,
                    docId: newPath.docId
                });
            });

            // Multi-selection event handlers - logs selection changes
            canvas.on('selection:created', function(e) {
                resetInactivityTimer(); // Reset timer on user activity
                console.log(`âœ… [selection:created] Selected ${e.selected ? e.selected.length : 0} object(s)`);
            });

            canvas.on('selection:updated', function(e) {
                resetInactivityTimer(); // Reset timer on user activity
                console.log(`âœ… [selection:updated] Selected ${e.selected ? e.selected.length : 0} object(s)`);
            });

            // Add listener for the slider UI
            if (zoomSlider) {
                zoomSlider.addEventListener('input', (e) => {
                    resetInactivityTimer(); // Reset timer on user activity
                    if (!canvas) return;
                    const zoom = parseFloat(e.target.value);
                    const center = canvas.getCenter();
                    canvas.zoomToPoint(new fabric.Point(center.left, center.top), zoom);
                    updateZoomUI();
                });
            }

            updateZoomUI(); // Set initial UI state
            activateTool('select');

            // Start inactivity timer for students
            if (userRole === 'student') {
                startInactivityTimer();
                console.log('[Inactivity] Timer started for student - 30 minutes timeout');
            }
        }

        // --- Inactivity Timer Functions (Student Auto-Logout) ---
        function startInactivityTimer() {
            // Clear any existing timer
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }

            // Set new timer for 30 minutes
            inactivityTimer = setTimeout(() => {
                console.log('[Inactivity] 30 minutes of inactivity detected - logging out student');
                showMessage('æ‚¨å·²ç¶“30åˆ†é˜æ²’æœ‰æ“ä½œï¼Œç³»çµ±è‡ªå‹•ç™»å‡ºã€‚');

                // Wait 2 seconds for message to be visible, then reload
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            }, INACTIVITY_TIMEOUT);
        }

        function resetInactivityTimer() {
            // Only reset for students
            if (userRole === 'student' && inactivityTimer) {
                clearTimeout(inactivityTimer);
                startInactivityTimer();
                // Uncomment for debugging: console.log('[Inactivity] Timer reset');
            }
        }

        // --- Toolbar & Tools Logic ---
        const toolButtons = document.querySelectorAll('.tool-btn');
        toolButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                resetInactivityTimer(); // Reset timer on user activity
                const tool = btn.dataset.tool;
                if (tool) activateTool(tool);
            });
        });

        function activateTool(tool) {
            console.log(`[activateTool] Switching to tool: ${tool}, previous tool: ${activeTool}`);
            console.log(`[activateTool] DEBUG: tool === 'delete'? ${tool === 'delete'}, tool type: ${typeof tool}`);
            const previousTool = activeTool;

            // IMPORTANT: Handle delete tool FIRST before discarding selection
            if (tool === 'delete') {
                console.log('ğŸ—‘ï¸ [activateTool] Delete tool activated - executing deletion');
                const activeObjects = canvas.getActiveObjects();
                console.log('ğŸ—‘ï¸ [activateTool] Selected objects before deletion:', activeObjects.length);
                deleteSelectedObjects();
                // After deletion, switch back to select tool
                console.log('ğŸ—‘ï¸ [activateTool] Deletion complete, switching back to select');
                activateTool('select');
                return;
            }

            console.log(`[activateTool] Not delete tool, continuing with normal flow`);

            activeTool = tool;

            document.getElementById('pen-options').classList.add('hidden');
            document.getElementById('note-options').classList.add('hidden');

            toolButtons.forEach(b => b.classList.remove('active'));
            const currentBtn = document.querySelector(`.tool-btn[data-tool="${tool}"]`);
            if(currentBtn) currentBtn.classList.add('active');

            if (!canvas) return;

            const isDrawingTool = ['pen', 'rect', 'circle'].includes(tool);
            const isSelectMode = tool === 'select';
            const isPanMode = tool === 'pan';

            canvas.isDrawingMode = tool === 'pen';
            // Enable multi-select box only for select mode
            canvas.selection = isSelectMode;

            console.log(`[activateTool] Set canvas.selection = ${isSelectMode} for tool: ${tool}`);

            // Set cursor based on tool
            if (isPanMode) {
                canvas.defaultCursor = 'grab';
            } else if (isSelectMode) {
                canvas.defaultCursor = 'default';
            } else {
                canvas.defaultCursor = 'crosshair';
            }

            // Discard any active selection when switching tools
            canvas.discardActiveObject();

            // Apply permissions to all objects
            const objects = canvas.getObjects();
            console.log(`[activateTool] Applying permissions to ${objects.length} objects`);
            objects.forEach(o => {
                applyObjectPermissions(o);
                o.setCoords(); // Update coordinates immediately
            });

            // Force canvas refresh
            canvas.requestRenderAll();

            // If switching TO select mode, do multiple refreshes to ensure newly created objects are selectable
            if (isSelectMode && previousTool !== 'select') {
                console.log(`[activateTool] Switching to select mode - applying additional refreshes`);

                // Ensure selection is enabled
                canvas.selection = true;

                // Immediate second refresh
                setTimeout(() => {
                    if (canvas && activeTool === 'select') {
                        canvas.selection = true;
                        canvas.forEachObject(o => {
                            applyObjectPermissions(o);
                            o.setCoords();
                        });
                        canvas.requestRenderAll();
                        console.log(`[activateTool] First delayed refresh complete, selection = ${canvas.selection}`);
                    }
                }, 50);

                // Third refresh for good measure (handles async object creation)
                setTimeout(() => {
                    if (canvas && activeTool === 'select') {
                        canvas.selection = true;
                        canvas.forEachObject(o => {
                            applyObjectPermissions(o);
                            o.setCoords();
                        });
                        canvas.requestRenderAll();
                        console.log(`[activateTool] Second delayed refresh complete, selection = ${canvas.selection}`);
                    }
                }, 150);
            }

            if (isDrawingTool) {
                document.getElementById('pen-options').classList.remove('hidden');
                // When activating pen tool, immediately apply the color and width from the toolbar
                if (tool === 'pen') {
                    const color = document.getElementById('pen-color').value;
                    const activeButton = document.querySelector('.pen-width-btn.active');
                    const width = activeButton ? parseInt(activeButton.dataset.width, 10) : 5;

                    // Ensure brush is initialized (important for iPad/touch devices)
                    if (!canvas.freeDrawingBrush) {
                        console.warn('[activateTool] ğŸ–Œï¸ Brush not initialized, creating new PencilBrush for iPad');
                        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                    }

                    canvas.freeDrawingBrush.color = color;
                    canvas.freeDrawingBrush.width = width;

                    console.log('âœï¸ [activateTool] Pen tool activated for iPad drawing', {
                        isDrawingMode: canvas.isDrawingMode,
                        brushColor: canvas.freeDrawingBrush.color,
                        brushWidth: canvas.freeDrawingBrush.width,
                        hasBrush: !!canvas.freeDrawingBrush
                    });

                    // Ensure drawing mode is active
                    if (!canvas.isDrawingMode) {
                        console.warn('[activateTool] âš ï¸ isDrawingMode was false, forcing to true for iPad drawing');
                        canvas.isDrawingMode = true;
                    }

                    // Double-check after setting
                    console.log('[activateTool] âœ… Final state check:', {
                        isDrawingMode: canvas.isDrawingMode,
                        activeTool: activeTool
                    });
                }
            } else if (tool === 'note') {
                document.getElementById('note-options').classList.remove('hidden');
            }
        }
        
        document.getElementById('pen-color').addEventListener('input', (e) => {
            if (canvas && canvas.isDrawingMode) canvas.freeDrawingBrush.color = e.target.value;
        });
        const penWidthButtons = document.querySelectorAll('#pen-options .pen-width-btn');
        penWidthButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const width = parseInt(e.currentTarget.dataset.width, 10);
                if (canvas && canvas.isDrawingMode) {
                    canvas.freeDrawingBrush.width = width;
                }
                penWidthButtons.forEach(b => b.classList.remove('active'));
                e.currentTarget.classList.add('active');
            });
        });
        // Set initial active state for pen width
        document.querySelector('.pen-width-btn[data-width="5"]').classList.add('active');
        
        function setupNewObject(obj) {
            // If authorUid is not set yet (local creation), set it
            if (!obj.authorUid && auth.currentUser) {
                obj.authorUid = auth.currentUser.uid;
            }
            applyObjectPermissions(obj); // Apply permissions
            canvas.add(obj);
            if (obj.type === 'image') {
                obj.sendToBack();
            }
            // Force update coordinates for touch devices
            obj.setCoords();
            canvas.requestRenderAll();
        }

        // Helper function to update merged pen strokes in Firestore
        async function updateMergedStrokeInFirestore(fabricObject) {
            if (!fabricObject || !fabricObject.docId) {
                console.warn('[updateMergedStrokeInFirestore] Object has no docId, skipping update');
                return;
            }

            try {
                const objectRef = doc(db, "sessions", sessionId, "canvasObjects", fabricObject.docId);
                const objData = fabricObject.toObject();

                // Handle path serialization for groups
                if (fabricObject.type === 'group') {
                    // Serialize each path in the group
                    objData.objects = objData.objects.map(obj => {
                        if (obj.type === 'path' && Array.isArray(obj.path)) {
                            obj.path = JSON.stringify(obj.path);
                        }
                        return obj;
                    });
                } else if (fabricObject.type === 'path' && Array.isArray(objData.path)) {
                    objData.path = JSON.stringify(objData.path);
                }

                console.log(`[updateMergedStrokeInFirestore] ğŸ’¾ Saving merged strokes:`, {
                    docId: fabricObject.docId,
                    type: fabricObject.type,
                    pathCount: fabricObject.type === 'group' ? fabricObject._objects.length : 1
                });

                await updateDoc(objectRef, {
                    data: objData,
                    type: fabricObject.type  // Update type in case it changed from path to group
                });

                console.log(`[updateMergedStrokeInFirestore] âœ… Merged strokes saved`);

                // Apply permissions and update display
                applyObjectPermissions(fabricObject);
                fabricObject.setCoords();
                canvas.requestRenderAll();

            } catch (error) {
                console.error('[updateMergedStrokeInFirestore] âŒ Error:', error);
            }
        }

        // Helper function to update object in Firestore (used for real-time updates during manipulation)
        async function updateObjectInFirestore(fabricObject) {
            if (!fabricObject || !fabricObject.docId) {
                console.warn('[updateObjectInFirestore] Object has no docId, skipping update');
                return;
            }

            try {
                const objectRef = doc(db, "sessions", sessionId, "canvasObjects", fabricObject.docId);

                // For path objects, include stroke/fill properties explicitly
                const propertiesToInclude = fabricObject.type === 'path'
                    ? ['stroke', 'strokeWidth', 'fill', 'strokeLineCap', 'strokeLineJoin', 'strokeMiterLimit']
                    : [];

                const objData = fabricObject.toObject(propertiesToInclude);

                if (fabricObject.type === 'path') {
                    // Ensure fill is explicitly set to null for stroke-only paths
                    if (!objData.fill || objData.fill === 'rgb(0,0,0)') {
                        objData.fill = null;
                    }

                    if (Array.isArray(objData.path)) {
                        objData.path = JSON.stringify(objData.path);
                    }
                }

                console.log(`[updateObjectInFirestore] ğŸ“¤ Real-time update:`, {
                    docId: fabricObject.docId,
                    type: fabricObject.type,
                    position: `(${objData.left?.toFixed(0)}, ${objData.top?.toFixed(0)})`,
                    scale: `(${objData.scaleX?.toFixed(2)}, ${objData.scaleY?.toFixed(2)})`,
                    angle: objData.angle?.toFixed(0),
                    isNewObject: fabricObject._justCreated
                });

                // CRITICAL FIX for iPad first object movement:
                // If the object was just created, use setDoc with merge instead of updateDoc
                // This handles the case where Firestore document might not be fully written yet
                if (fabricObject._justCreated) {
                    console.log(`[updateObjectInFirestore] ğŸ†• Object recently created, using setDoc with merge`);
                    await setDoc(objectRef, {
                        type: fabricObject.type,
                        data: objData,
                        authorUid: fabricObject.authorUid,
                        page: currentPage
                    }, { merge: true });
                } else {
                    await updateDoc(objectRef, { data: objData });
                }

                console.log(`[updateObjectInFirestore] âœ… Real-time update saved`);

                // Update author name text position if visible
                if (showAuthorNames && fabricObject.authorNameText) {
                    removeAuthorNameText(fabricObject);
                    addAuthorNameText(fabricObject);
                }
            } catch (error) {
                console.error('[updateObjectInFirestore] âŒ Error:', error);
                console.error('[updateObjectInFirestore] Error details:', {
                    code: error.code,
                    message: error.message,
                    docId: fabricObject.docId
                });

                // FALLBACK: If updateDoc fails (document might not exist yet), try setDoc
                if (error.code === 'not-found' || error.message?.includes('NOT_FOUND')) {
                    console.warn('[updateObjectInFirestore] ğŸ”„ Document not found, retrying with setDoc');
                    try {
                        const objectRef = doc(db, "sessions", sessionId, "canvasObjects", fabricObject.docId);
                        const objData = fabricObject.toObject();
                        if (fabricObject.type === 'path' && Array.isArray(objData.path)) {
                            objData.path = JSON.stringify(objData.path);
                        }
                        await setDoc(objectRef, {
                            type: fabricObject.type,
                            data: objData,
                            authorUid: fabricObject.authorUid,
                            page: currentPage
                        }, { merge: true });
                        console.log('[updateObjectInFirestore] âœ… Retry with setDoc successful');
                    } catch (retryError) {
                        console.error('[updateObjectInFirestore] âŒ Retry failed:', retryError);
                    }
                }
            }
        }

        async function addObjectToFirestore(fabricObject) {
            console.log('ğŸ¨ [addObjectToFirestore] Called from iPad/touch drawing', {
                hasObject: !!fabricObject,
                userRole: userRole,
                isLocked: isLocked,
                objectType: fabricObject?.type,
                currentPage: currentPage
            });

            if (!fabricObject) {
                console.error('[addObjectToFirestore] âŒ No fabricObject provided');
                return;
            }

            if (isLocked && userRole === 'student') {
                console.warn('[addObjectToFirestore] ğŸ”’ Student is locked, cannot add object');
                return;
            }

            try {
                // Set authorUid BEFORE any other operations
                if (!fabricObject.authorUid && auth.currentUser) {
                    fabricObject.authorUid = auth.currentUser.uid;
                    console.log('[addObjectToFirestore] âœï¸ Set authorUid:', auth.currentUser.uid);
                }

                console.log('[addObjectToFirestore] Step 1: ğŸ“‹ Preparing object data', {
                    authorUid: fabricObject.authorUid,
                    type: fabricObject.type,
                    hasPathData: fabricObject.type === 'path' && !!fabricObject.path
                });

                // Serialize object data with all necessary properties
                // For path objects, include stroke/fill properties explicitly
                const propertiesToInclude = fabricObject.type === 'path'
                    ? ['stroke', 'strokeWidth', 'fill', 'strokeLineCap', 'strokeLineJoin', 'strokeMiterLimit']
                    : [];

                const objData = fabricObject.toObject(propertiesToInclude);

                // For path objects, ensure path data is properly serialized
                if (fabricObject.type === 'path') {
                    // Ensure fill is explicitly set to null/empty for stroke-only paths
                    if (!objData.fill || objData.fill === 'rgb(0,0,0)') {
                        objData.fill = null;
                    }

                    if (Array.isArray(objData.path)) {
                        console.log(`[addObjectToFirestore] ğŸ“ Path has ${objData.path.length} points, converting to JSON string`);
                        objData.path = JSON.stringify(objData.path);
                    } else if (objData.path) {
                        console.warn(`[addObjectToFirestore] âš ï¸ Path is not an array:`, typeof objData.path);
                    } else {
                        console.error(`[addObjectToFirestore] âŒ Path object has no path data!`);
                    }

                    // Log detailed path info for debugging
                    console.log('[addObjectToFirestore] ğŸ“ Path details:', {
                        stroke: objData.stroke,
                        strokeWidth: objData.strokeWidth,
                        fill: objData.fill,
                        pathLength: Array.isArray(fabricObject.path) ? fabricObject.path.length : 'N/A'
                    });
                }

                console.log('[addObjectToFirestore] Step 2: ğŸ†” Generating Firestore document ID');

                // Generate a client-side ID to prevent race conditions with the snapshot listener
                const newDocRef = doc(collection(db, "sessions", sessionId, "canvasObjects"));

                // Set the ID on the local object and add it to the map BEFORE writing to Firestore
                fabricObject.docId = newDocRef.id;
                fabricObjects.set(newDocRef.id, fabricObject);

                // CRITICAL: Mark object as just created for iPad movement sync fix
                // This flag tells updateObjectInFirestore to use setDoc instead of updateDoc
                fabricObject._justCreated = true;
                console.log('[addObjectToFirestore] ğŸ†• Marked object as just created for safe updates');

                console.log(`[addObjectToFirestore] Step 3: ğŸ“¤ Saving to Firestore (docId: ${newDocRef.id}, page: ${currentPage})`);

                await setDoc(newDocRef, {
                    type: fabricObject.type,
                    data: objData,
                    authorUid: auth.currentUser.uid,
                    page: currentPage
                });

                console.log(`[addObjectToFirestore] âœ… Successfully saved to Firestore! Object will now sync to all users.`, {
                    docId: newDocRef.id,
                    type: fabricObject.type,
                    page: currentPage
                });

                // Remove the _justCreated flag after a delay to allow safe movement updates
                // This ensures the first few movement updates use setDoc instead of updateDoc
                setTimeout(() => {
                    if (fabricObject) {
                        fabricObject._justCreated = false;
                        console.log(`[addObjectToFirestore] â° Removed _justCreated flag for ${newDocRef.id}`);
                    }
                }, 1000); // 1 second should be enough for Firestore to fully commit the document

                if (showAuthorNames && fabricObject.authorUid) {
                    addAuthorNameText(fabricObject);
                }

                // Force refresh coordinates immediately after Firestore save
                fabricObject.setCoords();

                // IMPORTANT: Apply permissions based on CURRENT tool state
                // This ensures the object becomes selectable if we're already in select mode
                applyObjectPermissions(fabricObject);

                canvas.requestRenderAll();

                // Verify docId is set correctly
                if (!fabricObject.docId) {
                    console.error('[addObjectToFirestore] âŒ CRITICAL: docId missing after save!');
                } else {
                    console.log('[addObjectToFirestore] âœ… Object is ready for movement sync', {
                        docId: fabricObject.docId,
                        hasAuthorUid: !!fabricObject.authorUid,
                        inMap: fabricObjects.has(fabricObject.docId)
                    });
                }

                // Additional refresh to ensure the object is fully interactive
                setTimeout(() => {
                    if (canvas && fabricObject) {
                        applyObjectPermissions(fabricObject);
                        fabricObject.setCoords();
                        canvas.requestRenderAll();
                        console.log(`[addObjectToFirestore] ğŸ¯ Delayed refresh complete - object fully ready`);
                    }
                }, 100);

            } catch (error) {
                console.error("[addObjectToFirestore] âŒ Error:", error);
                console.error("[addObjectToFirestore] Error details:", {
                    message: error.message,
                    code: error.code,
                    stack: error.stack
                });
            }
        }

        function deleteSelectedObjects() {
            if (!canvas) {
                console.warn('âŒ [deleteSelectedObjects] Canvas not initialized');
                return;
            }

            const activeObjects = canvas.getActiveObjects();

            if (!activeObjects.length) {
                console.warn('âš ï¸ [deleteSelectedObjects] No objects selected');
                return;
            }

            console.log('ğŸ—‘ï¸ [deleteSelectedObjects] Attempting to delete objects', {
                count: activeObjects.length,
                userRole: userRole,
                objects: activeObjects.map(o => ({
                    type: o.type,
                    docId: o.docId,
                    authorUid: o.authorUid
                }))
            });

            let deletedCount = 0;
            let skippedCount = 0;

            activeObjects.forEach(obj => {
                // Permission check: Teachers can delete all objects, students can only delete their own
                const canDelete = userRole === 'teacher' ||
                                  (userRole === 'student' && obj.authorUid === auth.currentUser.uid);

                if (!canDelete) {
                    console.warn('âŒ [deleteSelectedObjects] Student cannot delete object created by another user', {
                        objectAuthorUid: obj.authorUid,
                        currentUserUid: auth.currentUser.uid,
                        objectType: obj.type
                    });
                    skippedCount++;
                    return; // Skip this object
                }

                console.log('âœ… [deleteSelectedObjects] Deleting object', {
                    docId: obj.docId,
                    type: obj.type,
                    authorUid: obj.authorUid,
                    userRole: userRole
                });

                if(obj.docId){
                    deleteDoc(doc(db, "sessions", sessionId, "canvasObjects", obj.docId));
                }
                // Also remove from local canvas immediately for better UX and to prevent race conditions.
                canvas.remove(obj);
                deletedCount++;
            });

            console.log(`ğŸ—‘ï¸ [deleteSelectedObjects] Deletion complete:`, {
                deleted: deletedCount,
                skipped: skippedCount,
                total: activeObjects.length
            });

            canvas.discardActiveObject();
            canvas.requestRenderAll();
        }

        let shape, isDown, origX, origY;
        function startDrawing(opt) {
            if (!canvas || !['rect', 'circle'].includes(activeTool)) return;
            
            isDown = true;
            const pointer = canvas.getPointer(opt.e);
            origX = pointer.x;
            origY = pointer.y;

            const sharedProps = {
                left: origX,
                top: origY,
                originX: 'left',
                originY: 'top',
                fill: 'rgba(255, 255, 255, 0)',
                stroke: document.getElementById('pen-color').value,
                strokeWidth: parseInt(document.getElementById('pen-width').value, 10) || 3
            };
            if (activeTool === 'rect') {
                shape = new fabric.Rect({ ...sharedProps, width: 0, height: 0 });
            } else if (activeTool === 'circle') {
                shape = new fabric.Circle({ ...sharedProps, radius: 0 });
            }
            setupNewObject(shape);
        }

        function continueDrawing(opt) {
             if (!isDown || !shape) return;
             const pointer = canvas.getPointer(opt.e);
             
             if (activeTool === 'rect') {
                if (origX > pointer.x) { shape.set({ left: Math.abs(pointer.x) }); }
                if (origY > pointer.y) { shape.set({ top: Math.abs(pointer.y) }); }
                shape.set({ width: Math.abs(origX - pointer.x), height: Math.abs(origY - pointer.y) });
             } else if (activeTool === 'circle') {
                shape.set({ radius: Math.sqrt(Math.pow(origX - pointer.x, 2) + Math.pow(origY - pointer.y, 2)) / 2 });
             }
             canvas.requestRenderAll();
        }

        function stopDrawing() {
            if (isDown && shape) {
                addObjectToFirestore(shape);
                shape = null;
            }
            isDown = false;
        }

        document.getElementById('note-options').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.color) {
                addStickyNote(e.target.dataset.color);
            }
        });

        function addStickyNote(color = '#FFFBEB') {
            if (!canvas) return;
            const center = canvas.getCenter();
            const vpCenter = fabric.util.transformPoint(center, canvas.viewportTransform);

            const note = new fabric.IText('é»æ­¤ç·¨è¼¯', {
                left: (center.left - canvas.viewportTransform[4]) / canvas.getZoom(),
                top: (center.top - canvas.viewportTransform[5]) / canvas.getZoom(),
                fontFamily: 'sans-serif',
                fill: '#1f2937',
                backgroundColor: color,
                padding: 10,
                fontSize: 24,
                width: 200,
                shadow: 'rgba(0,0,0,0.2) 2px 2px 5px'
            });
            setupNewObject(note);
            addObjectToFirestore(note);
            activateTool('select');
        }
        
        document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-input').click());
        document.getElementById('upload-pdf-btn').addEventListener('click', () => document.getElementById('pdf-input').click());

        document.getElementById('image-input').addEventListener('change', (e) => handleFile(e.target.files[0], 'image'));
        document.getElementById('pdf-input').addEventListener('change', (e) => handleFile(e.target.files[0], 'pdf'));

        async function handleFile(file, type) {
            if (!file) return;
            showLoading(true, 'æ­£åœ¨è™•ç†æª”æ¡ˆ...');
            try {
                if (type === 'image') {
                    const base64 = await resizeImage(file);
                    addImageToCanvas(base64);
                } else if (type === 'pdf') {
                    await renderPdfPreview(file);
                }
            } catch (error) {
                console.error(`Error handling file: ${type}`, error);
                showMessage(`è™•ç†${type === 'image' ? 'åœ–ç‰‡' : 'PDF'}æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚`);
            } finally {
                document.getElementById('image-input').value = '';
                document.getElementById('pdf-input').value = '';
                showLoading(false);
            }
        }

        function resizeImage(file, maxWidth = 600) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvasEl = document.createElement('canvas');
                        const ctx = canvasEl.getContext('2d');
                        let { width, height } = img;
                        if (width > maxWidth) {
                            height = (maxWidth / width) * height;
                            width = maxWidth;
                        }
                        canvasEl.width = width;
                        canvasEl.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvasEl.toDataURL('image/jpeg', 0.7));
                    };
                    img.onerror = reject;
                    img.src = event.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        function addImageToCanvas(base64) {
            if (!canvas) return;
            console.log("addImageToCanvas called with base64 length:", base64 ? base64.length : "null"); // Debug log
            fabric.Image.fromURL(base64, (img) => {
                console.log("fabric.Image.fromURL callback executed. Image object:", img); // Debug log
                if (!img) {
                    console.error("fabric.Image.fromURL failed to create image object.");
                    return;
                }
                const center = canvas.getCenter();
                img.set({
                    left: (center.left - canvas.viewportTransform[4]) / canvas.getZoom(),
                    top: (center.top - canvas.viewportTransform[5]) / canvas.getZoom(),
                    scaleX: 1 / canvas.getZoom(),
                    scaleY: 1 / canvas.getZoom(),
                });
                setupNewObject(img);
                addObjectToFirestore(img);
                console.log("Image added to canvas and Firestore."); // Debug log
            }, { crossOrigin: 'anonymous' }); // Add crossOrigin for potential issues with data URLs
        }

        async function renderPdfPreview(file) {
            const modal = document.getElementById('pdf-preview-modal');
            const grid = document.getElementById('pdf-preview-grid');
            grid.innerHTML = '';
            modal.classList.remove('hidden');

            try {
                const fileReader = new FileReader();
                fileReader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    const pdf = await pdfjsLib.getDocument(typedarray).promise;
                    const desiredWidth = 1024; // Set desired width to 1024px

                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        
                        // Calculate scale to achieve the desired width
                        const viewportDefault = page.getViewport({ scale: 1 });
                        const scale = desiredWidth / viewportDefault.width;
                        const viewport = page.getViewport({ scale: scale });

                        const canvasEl = document.createElement('canvas');
                        const ctx = canvasEl.getContext('2d');
                        canvasEl.height = viewport.height;
                        canvasEl.width = viewport.width;

                        await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                        
                        const pageDiv = document.createElement('div');
                        pageDiv.className = 'relative border-2 border-transparent rounded-lg cursor-pointer p-1';
                        pageDiv.innerHTML = `
                            <img src="${canvasEl.toDataURL('image/jpeg', 0.7)}" class="w-full h-auto rounded-md shadow-sm">
                            <div class="absolute inset-0 bg-blue-500 bg-opacity-50 hidden items-center justify-center">
                                <svg class="w-12 h-12 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                            </div>
                            <span class="absolute top-2 right-2 bg-gray-800 text-white text-xs rounded-full px-2 py-1">${i}</span>`;
                        pageDiv.dataset.pageNum = i;
                        pageDiv.addEventListener('click', () => {
                            pageDiv.classList.toggle('selected');
                            pageDiv.classList.toggle('border-blue-500');
                            pageDiv.querySelector('.absolute.inset-0').classList.toggle('hidden');
                            pageDiv.querySelector('.absolute.inset-0').classList.toggle('flex');
                        });
                        grid.appendChild(pageDiv);
                    }
                };
                fileReader.readAsArrayBuffer(file);
            } catch (error) {
                console.error("Error rendering PDF preview:", error);
                showMessage("è®€å–PDFæª”æ¡ˆå¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦æ­£å¸¸ã€‚");
                modal.classList.add('hidden');
            }
        }

        document.getElementById('insert-pdf-pages-btn').addEventListener('click', async () => {
            const selectedPageDivs = document.querySelectorAll('#pdf-preview-grid div.selected'); // Select the div with 'selected' class
            if (selectedPageDivs.length === 0) {
                showMessage('è«‹è‡³å°‘é¸æ“‡ä¸€å€‹é é¢ï¼');
                return;
            }
            showLoading(true, `æ­£åœ¨æ’å…¥ ${selectedPageDivs.length} å€‹é é¢...`);
            for (const pageDiv of selectedPageDivs) { // Iterate through the selected divs
                const img = pageDiv.querySelector('img'); // Get the img element inside the div
                if (img) {
                    try {
                        addImageToCanvas(img.src);
                    } catch (error) {
                        console.error("Error processing selected PDF page:", error);
                    }
                }
            }
            showLoading(false);
            document.getElementById('pdf-preview-modal').classList.add('hidden');
        });

        document.getElementById('close-pdf-modal').addEventListener('click', () => document.getElementById('pdf-preview-modal').classList.add('hidden'));

        document.getElementById('toggle-author-names-btn').addEventListener('click', async () => {
            if (userRole !== 'teacher') return; // Only teacher can toggle

            const sessionRef = doc(db, "sessions", sessionId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(sessionRef);
                    if (!sfDoc.exists()) throw "Document does not exist!";
                    const currentShowAuthorNames = sfDoc.data().metadata.showAuthorNames;
                    transaction.update(sessionRef, { "metadata.showAuthorNames": !currentShowAuthorNames });
                });
            } catch (e) {
                console.error("Toggle author names transaction failed: ", e);
            }
        });

        document.getElementById('lock-students-btn').addEventListener('click', async () => {
            const sessionRef = doc(db, "sessions", sessionId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(sessionRef);
                    if (!sfDoc.exists()) throw "Document does not exist!";
                    const currentLockState = sfDoc.data().metadata.isLocked;
                    transaction.update(sessionRef, { "metadata.isLocked": !currentLockState });
                });
            } catch (e) {
                console.error("Lock transaction failed: ", e);
            }
        });

        document.getElementById('download-pdf-btn').addEventListener('click', async () => {
            await downloadCanvasAsPDF();
        });

        document.getElementById('leave-session-btn').addEventListener('click', () => {
            window.location.reload();
        });

        document.getElementById('close-session-btn').addEventListener('click', async () => {
            const confirmed = await showConfirm(
                'âš ï¸ è­¦å‘Šï¼šæ¸…ç©ºè³‡æ–™åº«',
                'æ­¤æ“ä½œå°‡æ°¸ä¹…åˆªé™¤æ•´å€‹è³‡æ–™åº«çš„æ‰€æœ‰ç™½æ¿å…§å®¹ï¼Œä¸”ç„¡æ³•å¾©åŸã€‚ç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ'
            );
            if (confirmed) {
                deleteAllSessions();
            }
        });

        async function downloadCanvasAsPDF() {
            try {
                console.log('[ä¸‹è¼‰PDF] é–‹å§‹ç”ŸæˆPDF...');
                showLoading(true, 'æ­£åœ¨æº–å‚™ä¸‹è¼‰...');

                // ç²å–ç¸½é æ•¸
                const sessionRef = doc(db, "sessions", sessionId);
                const sessionSnap = await getDoc(sessionRef);

                if (!sessionSnap.exists()) {
                    showMessage('æ‰¾ä¸åˆ°ç™½æ¿è³‡æ–™');
                    showLoading(false);
                    return;
                }

                const metadata = sessionSnap.data().metadata;
                const totalPages = metadata.pageCount || 1;
                const originalPage = currentPage; // ä¿å­˜ç•¶å‰é é¢

                console.log(`[ä¸‹è¼‰PDF] ç¸½å…± ${totalPages} é `);

                // ä¿å­˜ç•¶å‰è¦–åœ–ç‹€æ…‹ï¼ˆç¸®æ”¾å’Œå¹³ç§»ï¼‰
                const savedZoom = canvas.getZoom();
                const savedVPT = canvas.viewportTransform.slice();
                console.log(`[ä¸‹è¼‰PDF] ä¿å­˜è¦–åœ–ç‹€æ…‹ - Zoom: ${savedZoom.toFixed(2)}, VPT: [${savedVPT.join(', ')}]`);

                // è¨ˆç®—ç•¶å‰å¯è¦‹å€åŸŸï¼ˆåŸºæ–¼ç•«å¸ƒå°ºå¯¸å’Œè¦–åœ–è®Šæ›ï¼‰
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                // è¨ˆç®—è¦–çª—ä¸­å¯¦éš›çœ‹åˆ°çš„ç•«å¸ƒå€åŸŸï¼ˆè€ƒæ…®ç¸®æ”¾å’Œå¹³ç§»ï¼‰
                const vpt = savedVPT;
                const zoom = savedZoom;

                // è¦–çª—å·¦ä¸Šè§’åœ¨ç•«å¸ƒåº§æ¨™ç³»ä¸­çš„ä½ç½®
                const viewLeft = -vpt[4] / zoom;
                const viewTop = -vpt[5] / zoom;
                const viewWidth = canvasWidth / zoom;
                const viewHeight = canvasHeight / zoom;

                console.log(`[ä¸‹è¼‰PDF] å¯è¦‹å€åŸŸ: left=${viewLeft.toFixed(0)}, top=${viewTop.toFixed(0)}, width=${viewWidth.toFixed(0)}, height=${viewHeight.toFixed(0)}`);

                // åˆå§‹åŒ–jsPDFï¼Œä½¿ç”¨å¯è¦‹å€åŸŸå°ºå¯¸
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: viewWidth > viewHeight ? 'landscape' : 'portrait',
                    unit: 'px',
                    format: [viewWidth, viewHeight]
                });

                // ç§»é™¤ä½œè€…åç¨±é¡¯ç¤ºï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
                const originalShowAuthorNames = showAuthorNames;
                if (showAuthorNames) {
                    canvas.forEachObject(obj => {
                        if (obj.authorUid) {
                            removeAuthorNameText(obj);
                        }
                    });
                    canvas.requestRenderAll();
                }

                // éæ­·æ¯ä¸€é 
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    showLoading(true, `æ­£åœ¨ç”Ÿæˆ PDF... (${pageNum}/${totalPages})`);
                    console.log(`[ä¸‹è¼‰PDF] æ­£åœ¨è™•ç†ç¬¬ ${pageNum} é ...`);

                    // åˆ‡æ›åˆ°è©²é é¢
                    if (pageNum !== currentPage) {
                        switchPage(pageNum);
                        // ç­‰å¾…é é¢è¼‰å…¥å®Œæˆ
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }

                    // å¥—ç”¨ä¿å­˜çš„è¦–åœ–ç‹€æ…‹
                    canvas.setViewportTransform(savedVPT);
                    canvas.setZoom(savedZoom);
                    canvas.requestRenderAll();

                    // ç­‰å¾…æ¸²æŸ“å®Œæˆ
                    await new Promise(resolve => setTimeout(resolve, 200));

                    // æ“·å–ç•¶å‰å¯è¦‹å€åŸŸçš„åœ–ç‰‡ï¼ˆé«˜è§£æåº¦ï¼Œå¸¶é™ç´šè™•ç†ï¼‰
                    let imgData = null;
                    const attempts = [
                        { multiplier: 2, quality: 1, format: 'png' },      // æœ€é«˜å“è³ª
                        { multiplier: 1.5, quality: 0.95, format: 'png' }, // é«˜å“è³ª
                        { multiplier: 1, quality: 0.9, format: 'png' },    // ä¸­å“è³ª
                        { multiplier: 1, quality: 0.85, format: 'jpeg' },  // JPEG ä¸­å“è³ª
                        { multiplier: 0.8, quality: 0.8, format: 'jpeg' }, // JPEG ä½å“è³ª
                        { multiplier: 0.5, quality: 0.7, format: 'jpeg' }  // æœ€ä½å“è³ª
                    ];

                    for (let i = 0; i < attempts.length; i++) {
                        try {
                            const config = attempts[i];
                            console.log(`[ä¸‹è¼‰PDF] å˜—è©¦é…ç½® ${i + 1}/${attempts.length}: multiplier=${config.multiplier}, quality=${config.quality}, format=${config.format}`);

                            imgData = canvas.toDataURL({
                                format: config.format,
                                quality: config.quality,
                                left: viewLeft,
                                top: viewTop,
                                width: viewWidth,
                                height: viewHeight,
                                multiplier: config.multiplier
                            });

                            console.log(`[ä¸‹è¼‰PDF] ç¬¬ ${pageNum} é åœ–ç‰‡ç”ŸæˆæˆåŠŸ (é…ç½® ${i + 1})`);
                            break; // æˆåŠŸå‰‡è·³å‡ºè¿´åœˆ
                        } catch (error) {
                            console.warn(`[ä¸‹è¼‰PDF] é…ç½® ${i + 1} å¤±æ•—:`, error.message);
                            if (i === attempts.length - 1) {
                                // æ‰€æœ‰å˜—è©¦éƒ½å¤±æ•—
                                throw new Error(`ç„¡æ³•ç”Ÿæˆç¬¬ ${pageNum} é çš„åœ–ç‰‡ï¼Œè«‹å˜—è©¦æ¸›å°‘ç•«å¸ƒå…§å®¹æˆ–ç¸®å°å¯è¦‹å€åŸŸ`);
                            }
                            // ç¹¼çºŒå˜—è©¦ä¸‹ä¸€å€‹é…ç½®
                        }
                    }

                    // æ·»åŠ åˆ°PDFï¼ˆç¬¬ä¸€é ä¸éœ€è¦addPageï¼‰
                    if (pageNum > 1) {
                        pdf.addPage([viewWidth, viewHeight]);
                    }

                    // å°‡åœ–ç‰‡æ·»åŠ åˆ°PDFï¼ˆå¡«æ»¿æ•´é ï¼Œè‡ªå‹•æª¢æ¸¬æ ¼å¼ï¼‰
                    const imageFormat = imgData.startsWith('data:image/jpeg') ? 'JPEG' : 'PNG';
                    pdf.addImage(imgData, imageFormat, 0, 0, viewWidth, viewHeight);
                    console.log(`[ä¸‹è¼‰PDF] ç¬¬ ${pageNum} é å·²æ·»åŠ  (${viewWidth.toFixed(0)}x${viewHeight.toFixed(0)} px, æ ¼å¼: ${imageFormat})`);
                }

                // æ¢å¾©ä½œè€…åç¨±é¡¯ç¤º
                if (originalShowAuthorNames) {
                    canvas.forEachObject(obj => {
                        if (obj.authorUid) {
                            addAuthorNameText(obj);
                        }
                    });
                    canvas.requestRenderAll();
                }

                // åˆ‡å›åŸå§‹é é¢ä¸¦æ¢å¾©è¦–åœ–
                if (currentPage !== originalPage) {
                    switchPage(originalPage);
                } else {
                    // ç¢ºä¿è¦–åœ–ç‹€æ…‹æ­£ç¢º
                    canvas.setViewportTransform(savedVPT);
                    canvas.setZoom(savedZoom);
                    canvas.requestRenderAll();
                }

                // ç”Ÿæˆæª”åï¼ˆæ ¼å¼ï¼šç™½æ¿_YYYYMMDD_HHMMSS.pdfï¼‰
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const filename = `ç™½æ¿_${year}${month}${day}_${hours}${minutes}${seconds}.pdf`;

                // ä¸‹è¼‰PDF
                pdf.save(filename);
                console.log(`[ä¸‹è¼‰PDF] PDFå·²ä¸‹è¼‰: ${filename}`);
                showLoading(false);
                showMessage(`PDFå·²æˆåŠŸä¸‹è¼‰ï¼\næª”åï¼š${filename}\nç¸½å…± ${totalPages} é `);

            } catch (error) {
                console.error('[ä¸‹è¼‰PDF] ç™¼ç”ŸéŒ¯èª¤:', error);
                showLoading(false);
                showMessage(`ä¸‹è¼‰PDFæ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}`);
            }
        }

        async function deleteAllSessions() {
            console.log('[æ¸…ç©ºè³‡æ–™åº«] é–‹å§‹æ¸…ç©ºæ•´å€‹Firebaseè³‡æ–™åº«...');
            showLoading(true, 'æ­£åœ¨æ¸…ç©ºè³‡æ–™åº«... (1/3)');

            try {
                // æ­¥é©Ÿ1: å–æ¶ˆæ‰€æœ‰ç›£è½å™¨ï¼Œé¿å…åˆªé™¤éç¨‹ä¸­è§¸ç™¼é‡æ–°è¼‰å…¥
                console.log('[æ¸…ç©ºè³‡æ–™åº«] æ­¥é©Ÿ1: å–æ¶ˆæ‰€æœ‰ç›£è½å™¨...');
                unsubscribes.forEach(unsub => {
                    try {
                        unsub();
                    } catch (e) {
                        console.warn('[æ¸…ç©ºè³‡æ–™åº«] å–æ¶ˆç›£è½å™¨æ™‚å‡ºéŒ¯:', e);
                    }
                });
                unsubscribes.length = 0;
                console.log('[æ¸…ç©ºè³‡æ–™åº«] æ‰€æœ‰ç›£è½å™¨å·²å–æ¶ˆ');

                showLoading(true, 'æ­£åœ¨æ¸…ç©ºè³‡æ–™åº«... (2/3)');

                // æ­¥é©Ÿ2: æŸ¥è©¢æ‰€æœ‰sessions
                console.log('[æ¸…ç©ºè³‡æ–™åº«] æ­¥é©Ÿ2: æŸ¥è©¢æ‰€æœ‰ç™½æ¿...');
                const sessionsRef = collection(db, "sessions");
                const sessionsSnap = await getDocs(sessionsRef);
                console.log(`[æ¸…ç©ºè³‡æ–™åº«] æ‰¾åˆ° ${sessionsSnap.size} å€‹ç™½æ¿`);

                // æ­¥é©Ÿ3: éæ­·æ¯å€‹sessionï¼Œåˆªé™¤å…¶å­é›†åˆå’Œä¸»æ–‡ä»¶
                let totalDeleted = 0;
                for (const sessionDoc of sessionsSnap.docs) {
                    const currentSessionId = sessionDoc.id;
                    console.log(`[æ¸…ç©ºè³‡æ–™åº«] æ­£åœ¨åˆªé™¤ç™½æ¿: ${currentSessionId}`);

                    // åˆªé™¤è©²sessionçš„æ‰€æœ‰participants
                    const participantsRef = collection(db, "sessions", currentSessionId, "participants");
                    const participantsSnap = await getDocs(participantsRef);
                    console.log(`  - æ‰¾åˆ° ${participantsSnap.size} å€‹åƒèˆ‡è€…`);

                    const deletePromises = [];
                    participantsSnap.forEach(doc => {
                        deletePromises.push(deleteDoc(doc.ref));
                    });

                    // åˆªé™¤è©²sessionçš„æ‰€æœ‰canvasObjects
                    const objectsRef = collection(db, "sessions", currentSessionId, "canvasObjects");
                    const objectsSnap = await getDocs(objectsRef);
                    console.log(`  - æ‰¾åˆ° ${objectsSnap.size} å€‹ç•«å¸ƒç‰©ä»¶`);

                    objectsSnap.forEach(doc => {
                        deletePromises.push(deleteDoc(doc.ref));
                    });

                    // ç­‰å¾…æ‰€æœ‰å­é›†åˆæ–‡ä»¶åˆªé™¤å®Œæˆ
                    await Promise.all(deletePromises);

                    // åˆªé™¤sessionä¸»æ–‡ä»¶
                    await deleteDoc(sessionDoc.ref);
                    console.log(`  - ç™½æ¿ ${currentSessionId} å·²åˆªé™¤`);
                    totalDeleted++;

                    showLoading(true, `æ­£åœ¨æ¸…ç©ºè³‡æ–™åº«... å·²åˆªé™¤ ${totalDeleted}/${sessionsSnap.size} å€‹ç™½æ¿`);
                }

                showLoading(true, 'æ­£åœ¨æ¸…ç©ºè³‡æ–™åº«... (3/3)');
                console.log(`[æ¸…ç©ºè³‡æ–™åº«] æˆåŠŸåˆªé™¤ ${totalDeleted} å€‹ç™½æ¿ï¼Œè³‡æ–™åº«å·²å®Œå…¨æ¸…ç©º`);

                // é©—è­‰è³‡æ–™åº«æ˜¯å¦å·²æ¸…ç©º
                const verifySnap = await getDocs(sessionsRef);
                if (verifySnap.size > 0) {
                    console.error(`[æ¸…ç©ºè³‡æ–™åº«] è­¦å‘Š: ä»æœ‰ ${verifySnap.size} å€‹ç™½æ¿å­˜åœ¨ï¼`);
                    throw new Error(`åˆªé™¤é©—è­‰å¤±æ•—ï¼šä»æœ‰ ${verifySnap.size} å€‹ç™½æ¿å­˜åœ¨`);
                }

                console.log('[æ¸…ç©ºè³‡æ–™åº«] è³‡æ–™åº«å·²å®Œå…¨æ¸…ç©ºï¼Œå³å°‡é‡æ–°è¼‰å…¥é é¢...');
                showLoading(true, 'è³‡æ–™åº«æ¸…ç©ºæˆåŠŸï¼æ­£åœ¨é‡æ–°è¼‰å…¥...');

                // å»¶é²å¾Œé‡æ–°è¼‰å…¥é é¢
                setTimeout(() => {
                    window.location.reload();
                }, 1500);

            } catch (error) {
                console.error("[æ¸…ç©ºè³‡æ–™åº«] æ¸…ç©ºéç¨‹ç™¼ç”ŸéŒ¯èª¤:", error);
                console.error("[æ¸…ç©ºè³‡æ–™åº«] éŒ¯èª¤è©³æƒ…:", error.message, error.code);
                showLoading(false);
                showMessage(`æ¸…ç©ºè³‡æ–™åº«æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}ã€‚è«‹æª¢æŸ¥æ§åˆ¶å°æ—¥èªŒä¸¦ç¨å¾Œå†è©¦ã€‚`);
            }
        }

        async function deleteSession() {
            console.log(`[åˆªé™¤ç™½æ¿] é–‹å§‹åˆªé™¤ç™½æ¿ ID: ${sessionId}`);
            showLoading(true, 'æ­£åœ¨åˆªé™¤ç™½æ¿è³‡æ–™... (1/4)');

            try {
                // æ­¥é©Ÿ1: åˆªé™¤æ‰€æœ‰åƒèˆ‡è€…è³‡æ–™
                console.log('[åˆªé™¤ç™½æ¿] æ­¥é©Ÿ1: æŸ¥è©¢åƒèˆ‡è€…è³‡æ–™...');
                const participantsRef = collection(db, "sessions", sessionId, "participants");
                const participantsSnap = await getDocs(participantsRef);
                console.log(`[åˆªé™¤ç™½æ¿] æ‰¾åˆ° ${participantsSnap.size} å€‹åƒèˆ‡è€…`);

                if (participantsSnap.size > 0) {
                    const deletePromises = [];
                    participantsSnap.forEach(docSnapshot => {
                        deletePromises.push(deleteDoc(docSnapshot.ref));
                    });
                    await Promise.all(deletePromises);
                    console.log('[åˆªé™¤ç™½æ¿] æ‰€æœ‰åƒèˆ‡è€…å·²åˆªé™¤');
                }

                showLoading(true, 'æ­£åœ¨åˆªé™¤ç™½æ¿è³‡æ–™... (2/4)');

                // æ­¥é©Ÿ2: åˆªé™¤æ‰€æœ‰ç•«å¸ƒç‰©ä»¶ï¼ˆåŒ…å«æ‰€æœ‰é é¢çš„åœ–ç‰‡ã€PDFã€ä¾¿åˆ©è²¼ã€ç¹ªåœ–ç­‰ï¼‰
                console.log('[åˆªé™¤ç™½æ¿] æ­¥é©Ÿ2: æŸ¥è©¢ç•«å¸ƒç‰©ä»¶...');
                const objectsRef = collection(db, "sessions", sessionId, "canvasObjects");
                const objectsSnap = await getDocs(objectsRef);
                console.log(`[åˆªé™¤ç™½æ¿] æ‰¾åˆ° ${objectsSnap.size} å€‹ç•«å¸ƒç‰©ä»¶`);

                if (objectsSnap.size > 0) {
                    const deletePromises = [];
                    objectsSnap.forEach(docSnapshot => {
                        deletePromises.push(deleteDoc(docSnapshot.ref));
                    });
                    await Promise.all(deletePromises);
                    console.log('[åˆªé™¤ç™½æ¿] æ‰€æœ‰ç•«å¸ƒç‰©ä»¶å·²åˆªé™¤');
                }

                showLoading(true, 'æ­£åœ¨åˆªé™¤ç™½æ¿è³‡æ–™... (3/4)');

                // æ­¥é©Ÿ3: å–æ¶ˆæ‰€æœ‰ç›£è½å™¨ï¼Œé¿å…åˆªé™¤éç¨‹ä¸­è§¸ç™¼é‡æ–°è¼‰å…¥
                console.log('[åˆªé™¤ç™½æ¿] æ­¥é©Ÿ3: å–æ¶ˆæ‰€æœ‰ç›£è½å™¨...');
                unsubscribes.forEach(unsub => {
                    try {
                        unsub();
                    } catch (e) {
                        console.warn('[åˆªé™¤ç™½æ¿] å–æ¶ˆç›£è½å™¨æ™‚å‡ºéŒ¯:', e);
                    }
                });
                unsubscribes.length = 0;
                console.log('[åˆªé™¤ç™½æ¿] æ‰€æœ‰ç›£è½å™¨å·²å–æ¶ˆ');

                showLoading(true, 'æ­£åœ¨åˆªé™¤ç™½æ¿è³‡æ–™... (4/4)');

                // æ­¥é©Ÿ4: æœ€å¾Œåˆªé™¤ä¸»è¦çš„sessionæ–‡ä»¶ï¼ˆåŒ…å«metadataï¼‰
                console.log('[åˆªé™¤ç™½æ¿] æ­¥é©Ÿ4: åˆªé™¤ä¸»sessionæ–‡ä»¶...');
                const sessionRef = doc(db, "sessions", sessionId);
                await deleteDoc(sessionRef);
                console.log('[åˆªé™¤ç™½æ¿] ä¸»sessionæ–‡ä»¶å·²åˆªé™¤');

                // é©—è­‰åˆªé™¤æ˜¯å¦æˆåŠŸ
                const verifyDoc = await getDoc(sessionRef);
                if (verifyDoc.exists()) {
                    console.error('[åˆªé™¤ç™½æ¿] éŒ¯èª¤: sessionæ–‡ä»¶ä»ç„¶å­˜åœ¨ï¼');
                    throw new Error('åˆªé™¤é©—è­‰å¤±æ•—ï¼šsessionæ–‡ä»¶ä»ç„¶å­˜åœ¨');
                }

                console.log(`[åˆªé™¤ç™½æ¿] ç™½æ¿ ${sessionId} å·²å®Œå…¨åˆªé™¤ï¼Œå³å°‡é‡æ–°è¼‰å…¥é é¢...`);
                showLoading(true, 'åˆªé™¤æˆåŠŸï¼æ­£åœ¨é‡æ–°è¼‰å…¥...');

                // å»¶é²ä¸€ä¸‹å†é‡æ–°è¼‰å…¥ï¼Œç¢ºä¿åˆªé™¤æ“ä½œå®Œå…¨å®Œæˆ
                setTimeout(() => {
                    window.location.reload();
                }, 1000);

            } catch (error) {
                console.error("[åˆªé™¤ç™½æ¿] åˆªé™¤éç¨‹ç™¼ç”ŸéŒ¯èª¤:", error);
                console.error("[åˆªé™¤ç™½æ¿] éŒ¯èª¤è©³æƒ…:", error.message, error.code);
                showLoading(false);
                showMessage(`åˆªé™¤ç™½æ¿æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}ã€‚è«‹æª¢æŸ¥æ§åˆ¶å°æ—¥èªŒä¸¦ç¨å¾Œå†è©¦ã€‚`);
            }
        }

        async function deletePage(pageNum) {
            const sessionRef = doc(db, "sessions", sessionId);
            const sessionSnap = await getDoc(sessionRef);
            if (!sessionSnap.exists()) return;
            const pageCount = sessionSnap.data().metadata.pageCount || 1;

            if (pageCount <= 1) {
                showMessage("ç„¡æ³•åˆªé™¤æœ€å¾Œä¸€é ç•«å¸ƒã€‚");
                return;
            }

            const confirmed = await showConfirm(
                'âš ï¸ ç¢ºèªåˆªé™¤ç•«å¸ƒ',
                `æ‚¨ç¢ºå®šè¦æ°¸ä¹…åˆªé™¤ç¬¬ ${pageNum} é çš„æ‰€æœ‰å…§å®¹å—ï¼Ÿæ­¤å‹•ä½œç„¡æ³•å¾©åŸã€‚`
            );
            if (!confirmed) return;

            showLoading(true, `æ­£åœ¨åˆªé™¤ç¬¬ ${pageNum} é ...`);

            try {
                // Step 1: Delete all objects on the target page
                const objectsToDeleteQuery = query(collection(db, "sessions", sessionId, "canvasObjects"), where("page", "==", pageNum));
                const objectsToDeleteSnap = await getDocs(objectsToDeleteQuery);
                if (!objectsToDeleteSnap.empty) {
                    const deleteBatch = writeBatch(db);
                    objectsToDeleteSnap.forEach(doc => deleteBatch.delete(doc.ref));
                    await deleteBatch.commit();
                    console.log(`[Delete Page] Deleted ${objectsToDeleteSnap.size} objects from page ${pageNum}.`);
                }

                // Step 2: Re-number subsequent pages
                if (pageNum < pageCount) {
                    const objectsToShiftQuery = query(collection(db, "sessions", sessionId, "canvasObjects"), where("page", ">", pageNum));
                    const objectsToShiftSnap = await getDocs(objectsToShiftQuery);
                    
                    if (!objectsToShiftSnap.empty) {
                        let updateBatch = writeBatch(db);
                        let count = 0;
                        for (const doc of objectsToShiftSnap.docs) {
                            updateBatch.update(doc.ref, { page: doc.data().page - 1 });
                            count++;
                            if (count === 499) { // Commit in chunks
                                await updateBatch.commit();
                                updateBatch = writeBatch(db);
                                count = 0;
                            }
                        }
                        if (count > 0) { // Commit the final batch
                            await updateBatch.commit();
                        }
                        console.log(`[Delete Page] Re-numbered ${objectsToShiftSnap.size} objects.`);
                    }
                }

                // Step 3: Decrement pageCount in metadata
                await updateDoc(sessionRef, { "metadata.pageCount": pageCount - 1 });
                console.log(`[Delete Page] Decremented pageCount to ${pageCount - 1}.`);

                // Step 4: Switch to a valid page if the current one was deleted
                if (currentPage === pageNum) {
                    const newPage = Math.max(1, pageNum - 1);
                    switchPage(newPage);
                } else if (currentPage > pageNum) {
                    switchPage(currentPage - 1);
                }
                
                showMessage(`ç¬¬ ${pageNum} é å·²æˆåŠŸåˆªé™¤ã€‚`);

            } catch (error) {
                console.error("Error deleting page: ", error);
                showMessage(`åˆªé™¤é é¢æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }

        function handleLockState(locked) { // 'locked' here refers to the global lock state
            isLocked = locked; // Update global lock state tracker
            const lockIcon = document.getElementById('lock-icon');
            const lockMessage = document.getElementById('lock-message');

            // Teacher UI for global lock button
            if (lockIcon) {
                if (locked) {
                    lockIcon.classList.add('text-red-500');
                } else {
                    lockIcon.classList.remove('text-red-500');
                }
            }
            
            if (userRole === 'student') {
                // Determine combined lock state for student
                const combinedLockedState = isLocked || isCurrentUserIndividuallyLocked;

                // Show/hide lock message
                if (combinedLockedState) {
                    lockMessage.classList.remove('hidden');
                } else {
                    lockMessage.classList.add('hidden');
                }

                // Disable/enable toolbar buttons
                const toolbar = document.getElementById('toolbar');
                toolbar.querySelectorAll('button, input').forEach(el => {
                    if(!el.closest('#teacher-tools')) el.disabled = combinedLockedState;
                });
            }

            // Re-apply object permissions for all objects on canvas
            if (canvas) {
                canvas.forEachObject(o => applyObjectPermissions(o)); // applyObjectPermissions already checks combined state
                if(isLocked || isCurrentUserIndividuallyLocked) activateTool('select'); // Force select tool if any lock is active
                canvas.requestRenderAll();
            }
        }
        


        function showLoading(show, text = 'è™•ç†ä¸­...') {
            loadingText.textContent = text;
            if (show) {
                loadingOverlay.classList.remove('hidden');
            } else {
                loadingOverlay.classList.add('hidden');
            }
        }
        
        function applyObjectPermissions(obj) {
            let isSelectable = false;
            const debugInfo = {
                type: obj.type,
                hasAuthorUid: !!obj.authorUid,
                isOwner: obj.authorUid === auth.currentUser?.uid,
                userRole: userRole,
                activeTool: activeTool
            };

            if (userRole === 'teacher') {
                isSelectable = true;
            } else if (userRole === 'student') {
                // Check if current student is locked by teacher
                const currentParticipant = participantDataMap.get(auth.currentUser.uid);
                const isCurrentUserLockedByTeacher = currentParticipant ? currentParticipant.isLockedByTeacher : false;

                if (isLocked || isCurrentUserLockedByTeacher) { // If global lock or per-student lock is active
                    isSelectable = false;
                    debugInfo.reason = 'locked';
                } else { // If not locked, apply author-based permissions
                    if (obj.authorUid === auth.currentUser.uid) {
                        isSelectable = true;
                        debugInfo.reason = 'owner';
                    } else {
                        isSelectable = false;
                        debugInfo.reason = 'not owner';
                    }
                }
            }

            // Global override: if the current tool is not 'select', nothing is interactive.
            const beforeToolCheck = isSelectable;
            if (activeTool !== 'select') {
                isSelectable = false;
                debugInfo.toolOverride = true;
            }

            // Debug logging for student's own objects
            if (userRole === 'student' && obj.authorUid === auth.currentUser.uid && obj.type === 'path') {
                console.log(`[applyObjectPermissions] Student's path object:`, {
                    ...debugInfo,
                    beforeToolCheck,
                    finalSelectable: isSelectable,
                    objectId: obj.docId || 'no-docId'
                });
            }

            // Set properties and ensure they are applied
            obj.set({
                selectable: isSelectable,
                evented: isSelectable,
                hasControls: isSelectable,
                hasBorders: isSelectable,
                hoverCursor: isSelectable ? 'move' : 'default'
            });

            // Force the object to update its coordinates
            obj.setCoords();
        }

        function addAuthorNameText(obj) {
            if (!obj.authorUid || !participantDataMap.has(obj.authorUid)) return;

            const authorName = participantDataMap.get(obj.authorUid).name; // Get name from participantDataMap
            const text = new fabric.Text(authorName, {
                fontSize: 14,
                fill: '#0000FF', // Blue text
                backgroundColor: '#FFFF00', // Yellow background
                fontWeight: 'bold', // Bold text
                padding: 1,
                evented: false,
                selectable: false,
                hasControls: false,
                hasBorders: false,
                originX: 'right',
                originY: 'top',
                textBaseline: 'top', // Changed to 'top' to test CanvasTextBaseline issue
            });

            // Calculate position relative to the object's top-right corner
            text.set({
                left: obj.left + obj.getScaledWidth(),
                top: obj.top,
            });

            canvas.add(text);
            obj.authorNameText = text;
            canvas.bringToFront(text);
        }

        function removeAuthorNameText(obj) {
            if (obj.authorNameText) {
                canvas.remove(obj.authorNameText);
                obj.authorNameText = null;
            }
        }

        function openParticipantListModal() {
            if (userRole !== 'teacher') return; // Only teacher can open
            document.getElementById('participant-list-modal').classList.remove('hidden');
            renderParticipantList();
        }

        function closeParticipantListModal() {
            document.getElementById('participant-list-modal').classList.add('hidden');
        }

        function renderParticipantList() {
            const container = document.getElementById('participant-list-container');
            container.innerHTML = ''; // Clear previous list

            // Sort participants: teacher first, then students by name
            const sortedParticipants = Array.from(participantDataMap.values()).sort((a, b) => {
                if (a.role === 'teacher' && b.role !== 'teacher') return -1;
                if (a.role !== 'teacher' && b.role === 'teacher') return 1;
                return a.name.localeCompare(b.name);
            });

            sortedParticipants.forEach(p => {
                const participantDiv = document.createElement('div');
                participantDiv.className = 'flex items-center justify-between p-2 bg-gray-50 rounded-md shadow-sm';
                
                let statusText = '';
                let statusColor = 'text-gray-600';
                if (p.role === 'teacher') {
                    statusText = 'è€å¸«';
                    statusColor = 'text-blue-600';
                } else {
                    statusText = 'å­¸ç”Ÿ';
                    statusColor = 'text-green-600';
                    if (p.isLockedByTeacher) {
                        statusText += ' (å·²é–å®š)';
                        statusColor = 'text-red-600';
                    }
                }

                participantDiv.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="font-semibold">${p.name}</span>
                        <span class="${statusColor} text-sm">(${statusText})</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        ${p.role === 'student' ? `
                            <button data-uid="${p.uid}" class="toggle-lock-btn p-2 rounded-full ${p.isLockedByTeacher ? 'bg-red-500 text-white' : 'bg-gray-200 text-gray-700'} hover:opacity-80" title="${p.isLockedByTeacher ? 'è§£é–å­¸ç”Ÿ' : 'é–å®šå­¸ç”Ÿ'}">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${p.isLockedByTeacher ? '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>' : '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>'}</svg>
                            </button>
                            <button data-uid="${p.uid}" class="kick-student-btn p-2 rounded-full bg-red-500 text-white hover:opacity-80" title="è¸¢å‡ºå­¸ç”Ÿ">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><line x1="17" y1="17" x2="22" y2="22"></line><line x1="22" y1="17" x2="17" y2="22"></line></svg>
                            </button>
                        ` : ''}
                    </div>
                `;
                container.appendChild(participantDiv);
            });

            // Add event listeners for new buttons
            container.querySelectorAll('.toggle-lock-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const uid = e.currentTarget.dataset.uid;
                    toggleStudentLock(uid);
                });
            });
            container.querySelectorAll('.kick-student-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const uid = e.currentTarget.dataset.uid;
                    kickParticipant(uid);
                });
            });
        }

        async function toggleStudentLock(uid) {
            const participantRef = doc(db, "sessions", sessionId, "participants", uid);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(participantRef);
                    if (!sfDoc.exists()) throw "Participant does not exist!";
                    const currentLockState = sfDoc.data().isLockedByTeacher;
                    transaction.update(participantRef, { "isLockedByTeacher": !currentLockState });
                });
            } catch (e) {
                console.error("Toggle student lock transaction failed: ", e);
            }
        }

        async function kickParticipant(uid) {
            const participantData = participantDataMap.get(uid);
            const studentName = participantData ? participantData.name : 'æ­¤å­¸ç”Ÿ';

            const confirmed = await showConfirm(
                'è¸¢å‡ºå­¸ç”Ÿ',
                `ç¢ºå®šè¦å°‡ "${studentName}" è¸¢å‡ºç™½æ¿å—ï¼Ÿ`
            );
            if (!confirmed) return;

            const participantRef = doc(db, "sessions", sessionId, "participants", uid);
            try {
                await deleteDoc(participantRef);
            } catch (e) {
                console.error("Kick participant failed: ", e);
                showMessage("è¸¢å‡ºå­¸ç”Ÿå¤±æ•—ã€‚");
            }
        }

        function resizeCanvas() {
            if (canvas) {
                canvas.setWidth(window.innerWidth);
                canvas.setHeight(window.innerHeight);
                canvas.renderAll();
            }
        }

        window.addEventListener('keydown', (e) => {
            resetInactivityTimer(); // Reset timer on user activity

            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.isContentEditable || activeEl.tagName === 'TEXTAREA')) return;

            if (e.key.toLowerCase() === 'p' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
            }

            switch(e.key.toLowerCase()) {
                case 'v': activateTool('select'); break;
                case 'p': activateTool('pen'); break;
                case 'r': activateTool('rect'); break;
                case 'c': activateTool('circle'); break;
                case 'h': activateTool('pan'); break;
                case 'n': activateTool('note'); break;
                case 'i': document.getElementById('upload-image-btn').click(); break;
                case 'f': document.getElementById('upload-pdf-btn').click(); break;
                case 'delete':
                case 'backspace':
                    deleteSelectedObjects();
                    break;
            }
        });

        // Event listeners for participant list modal
        document.getElementById('participant-display').addEventListener('click', openParticipantListModal);
        document.getElementById('close-participant-list-modal').addEventListener('click', closeParticipantListModal);
        document.getElementById('refresh-participant-list-btn').addEventListener('click', renderParticipantList);

        initApp();

    </script>
</body>
</html>

